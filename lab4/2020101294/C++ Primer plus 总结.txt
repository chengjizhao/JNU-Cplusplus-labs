第五章
1. for循环
for循环为执行重复的操作提供了循序渐进的过程。
for循环是入口条件（entry-condition）循环。

1.1 for循环的组成部分
设置变量初始化
执行测试，查看循环是否继续进行。
执行循环操作
不断更新测试的值

1.2 for循环的通用格式

statement01
for (initialization;test-expression;update-expression)
    statement01;
statement03;

说明：test_expression 决定了程序是否执行， 这里的表达式也就是所谓的关系表达式，即两个数进行比较。

C++中常用的方式：在for和括号之间加上一个空格，而省略函数名与括号之间的空格。

for(int i = 6;i<=12;i++);
    printf("i = %d\n",i);

1.3 递增运算符(++)和递减运算符(--)
递增/递减：增加/减少一个单位

前缀和后缀的区别
1.前缀递增/递减：表示操作符（++/--）位于变量或表达式的前面。
先执行运算，再生成值。
2.后缀递增/递减：表示操作符（++/--）位于变量或表达式的后面。
先生成值，再执行运算。

将递增 / 递减运算符用于指针时，把指针增加/减少其指向的数据类型占用的字节数。

 double arr[5] = {2.3,7.5,3.7,6.5,7.8};
 double *pt = arr;
 ++pt;

前缀/后缀递增 / 递减运算符的优先级前缀递增、前缀递减和解除引用运算符的优先级相同，从左往右的方式进行结合。
后缀递增和后缀递减的优先级相同，但是比前缀运算符的优先级高，从左往右的方式进行结合。

1.4 组合复制运算符
就是合并了算术运算符和赋值操作的运算符。

操作符	作用（L为左操作数，R为右操作数）
+=	将L+R赋给L
-=	将L-R赋给L
*=	将L*R赋给L
/=	将L/R赋给L
%=	将L%R赋给L

1.5 关系表达式
注意：等于运算符（==）和赋值运算符（=）两者不要混淆。
比较两个量是否相等时，而要使用 ==。

1.6 C-风格的字符串
数组名是数组的地址。用引号括起来的字符串常量也是其地址。
C-风格字符串库中的strcmp()函数来比较，函数接收两个字符串地址作为参数（参数可以是指针、字符串常量或字符数组名）。
如果字符串相同，函数返回 0；
如果第一个字符串按字母顺序排在第二个字符串之前，则strcmp()函数返回一个负值。
如果第一个字符串按字母顺序排在第二个字符串之后，则strcmp()函数返回一个正值。

2. while循环
while循环是没有初始化和更新部分的for循环。只有测试条件和循环体。

2.1 while循环的语法格式

while(test-condition)
    loop-body

3. do while循环

4. 循环与文本输入

5. 循环嵌套和二维数组

设计循环的指导原则
指定循环终止的条件
在首次测试之前初始化条件
在条件被再次测试之前更新条件。

第六章
1.if语句
if语句的概述
if语句是让程序能够决定是否执行特定的语句。

if语句的语法格式为：

if(test-condition)
    statement

和while语句的语法格式相似。
如果test-condition（测试条件）为true，即程序执行statement（语句）。

对于statement，既可以是语句，也可以是语句块。
如果条件为false ,程序跳过语句或语句块。和循环的测试条件一样。

if else语句
if else 语句则让程序执行两条语句或语句块中的哪一条。

if else语句的语法格式
if(test-condition)
    statement01
else
    statement02

如果测试条件为true或非零，则程序执行statement01，跳过statement02；
如果测试条件为false或0，则程序将跳过statement01，执行statement02。
注意：每一条语句既可以是一条语句，也可以是大括号 括起来的语句块。

2.逻辑表达式
假设expr01的值为 1，expr02的值为0。

运算符	含义	例子
&&	逻辑与（AND）运算符。如果两个操作数都非零，则条件为真。	(expr01 && expr02) 为假
`		`
!	逻辑非（NOT）运算符。用来逆转操作数的逻辑状态。如果条件为真，则逻辑非运算符使其转为假。	!(expr01&&expr02) 为真

3.字符函数库
cctype库中的字符函数
函数名称	返回值
isalnum()	如果参数是字母数字，即字母或数字，函数返回值是true
isalpha()	如果参数是字母，函数返回值是true
iscntr()	如果参数是控制字符，函数返回值true
isdigit()	如果参数是数字（0 ～ 9），函数返回值是true
isgraph()	如果参数是除了空格之外的打印字符，函数返回值是true
islower()	如果参数是小写字母，函数返回值是true
isprint()	如果参数是打印字符（包括空格），函数返回值是true
ispunct()	如果参数是标点符号，函数返回值是true
isspace()	如果参数是标准空白字符，如空格、进制、换行符、回车、水平制表符或者垂直制表符，函数返回值是true
isupper()	如果参数是大写字母，函数返回值是true
isxdigit()	如果参数是十六进制数字，即0～9、a～f或A～F，函数的返回值是true
tolower()	如果参数是大写字母，则返回其小写，否则返回该参数
toupper()	如果参数是小写字母，则返回其大写，否则返回该参数

5.switch语句
switch语句的总结
允许测试一个变量等于多个值时的情况。

switch语句的通用格式

switch(expression){
    case label01:
            statement(s);
            break; // 可选
    case label02:
            statement(s);
            break; // 可选

    default : // 可选
            statement(s);
}

遵循的规则：
expression 必须是一个整型或枚举类型，或者是一个 class 类型，其中 class 有一个单一的转换函数将其转换为整型或枚举类型。
case的个数是任意的，每个case后跟一个要比较的值和一个冒号。
case中的label必须和expression中的变量的数据类型相同，且必须是常量或者字面值。
遇到break语句时，switch语句直接终止。
default的执行是因为前面的case都不为真。

8.简单文件的输入/输出
文本I/O 和 文本文件
使用cin进行输入时，程序将输入视为一系列的字节，其中每个字节都被解释为字符编码。

不管目标数据类型是什么，输入一开始都是字符数据 ———— 文本数据。

cin对象是负责把文本类型转换为其他的类型。

控制台文本文件的输入：

必须包含头文件iostream。
头文件iostream定义了用于处理输入的istream类。
头文件iostream声明了一个名为cout的ostream（类）变量（对象）。
必须指明名称空间std。
结合使用cin和运算符>>来读取各种类型的数据。
使用 cin 和 eof() 、fail() 方法来判断输入是否成功。
对象cin本身被用作测试条件时，如果最后一个读取操作成功，将转换为布尔值true，否则转换为false。

文本文件的输出：

必须包含头文件iostream。
头文件iostream定义了用于处理输出的ostream类。
头文件iostream声明了一个名为cout的ostream（类）变量（对象）。
必须指明名称空间std::。
结合使用cout和运算符<<来显示各种类型的数据。
需要声明一个或者是多个ofstream变量（对象）,并对其命名，注意：遵守命名规则。
需要将ofstream对象与文件关联起来。方法之一：使用open()方法。
使用完文件，使用close()方法将其关闭。
结合使用ofstream对象和运算符<<来输出各种类型的数据。

使用文件输出的基本步骤：
包含头文件fstream。
创建一个ofstream对象。
将该ofstream对象同一个文件关联起来。
像使用cout一样使用ofstream对象。

第七章
1.复习函数的基本知识
对于C++中函数，必须有以下三种工作：
提供函数定义
提供函数的原型
调用函数
定义函数

将函数分为两类：
没有返回值的函数（也称为void函数）
通用的格式：

void functionName(parameterList) // parameterList指定传递给函数的参数类型和数量。
{
    statement(s)
    return; // option
}

有返回值的函数
有返回值的函数将生成一个值，并将它返回给调用函数。

通用的格式：

typeName FunctionName(parameterList)
{
    statements
    return value
}

对于返回值的函数，必须使用 返回语句 以便将值返回给调用函数。

值 - - - - 可以是 常量、变量、表达式。返回结果的类型必须是 typeName 类型 或 可以转换为typeName。

C++对返回值的类型有一定的限制：不能是数组。也可以是 其他的任何类型（整数、浮点数、指针、甚至是结构和对象）。

函数定义命令被调用函数应返回什么类型的数据。

函数原型和函数调用
为什么需要函数原型？
原型描述了函数到编译器的接口，也就是将函数返回值的类型以及参数的类型和数量告诉编译器。
避免使用函数原型的办法：在首次使用函数之前定义。

函数原型的语法
函数原型就是一个语句。必须以 分号（;） 结束。
最简单的办法：复制函数中的函数头，然后添加分号。
对于函数原型不要求提供变量名，有类型列表即可。
而函数的参数列表 中，可以包括变量名、也可以不包括，原型中的变量名相当于占位符，可以不和函数定义中的变量名相同。

函数原型的功能
编译器正确处理函数返回值。
编译器检查使用的参数数目是否正确。
编译器检查使用的参数类型是否正确。如果不正确，则转换为正确的类型。

3.函数参数和按值传递
形参和实参
用于接收传递值的变量被称为形参。传递给函数的值叫做实参。
在C++标准中，使用参数（argument）来表示实参，而参量（parameter）来表示形参。所以，参数传递就是 将参数赋给参量。

局部变量
在函数中声明的变量（包括参数）为该函数私有。
在函数被调用时，计算机为其变量分配内存，函数结束，就释放内存。这种变量叫做局部变量。

参数问题
函数可以有多个参数，在调用函数是，使用 逗号 分隔开。
如果函数的两个参数的类型相同，则必须分别指明每个参数的类型，不可以像声明常规变量那样组合在一起。

10.函数指针
与数据项一样，函数也有地址，函数的地址是存储其机器语言代码的内存的开始地址。

如果要使用的算法函数的地址传递给某一个函数。必须有以下内容：

1.获取函数的地址
获取函数地址的方式：使用函数名（后面不带参数）即可。

要将函数作为参数传递，必须传递函数名。一定要区分传递的是函数地址还是函数的返回值。

2.声明函数指针
声明指向某种数据类型的指针时，必须指定指针指向的类型。
对于函数而言，声明指向函数的指针时，也必须指定指针指向的函数类型。也就是说，声明应像函数原型一样指出函数的信息。

例如：

double foodName(char c); // 函数原型
假设声明一个指针类型的函数

int countdown(int);
使用(*cd)替换countdown，如下：

int  (*cd)(int); 

由于countdown是函数，(*cd)也是函数，如果 (*cd)是函数，所以cd就是函数指针。

小技巧：要声明指向特定类型的函数的指针，可以先写函数的原型，然后用(*pointer) 替换函数名，这样，pointer就是函数指针。
加括号的原因：括号的优先级高于*运算符。
注意点：

double (*pt)(int); // pt是指向函数的指针

double *pt(int); //  pt()是一个返回double类型指针的函数

3.使用函数指针来调用函数
使用指针来调用被指向的函数。

double (*pt)(int);
(*pt)的意义和函数名相同，所以使用(*pt)时，只需看作函数名即可。
double pf(int);
double (*pt)(int);
pt = pf; // pf是指针等于pf函数
double x = pf(4); // 使用函数名调用pf()
double y = (*pt)(5); // 使用指针调用pf()

第八章
1.内联函数
编译过程的目标是可执行程序（由一组机器语言指令组成）。运行程序时，操作系统将指令载入到计算机内存中，则每条指令都有其特定的内存地址。
内联函数的编译代码与其它程序代码内联，编译器就使用相应的函数代码替换函数调用。

1.1 常规函数和内联函数
常规函数：调用使得程序调到另一个地址（函数的地址），并在函数结束时返回。
将程序流程转到独立的函数。

内联函数：程序无需跳到另一个位置处执行代码，再跳回来。
用内联函数的代码来替换函数调用。

1.2 内联函数的优缺点
优点：运行速度比常规函数快。
缺点：占用内存大

1.3 使用内联函数的要求
在函数声明前加上关键字inline
在函数定义前加上关键字inline
一般用法：省略原型，将整个定义（函数头和所有函数代码）放在本应提供原型的地方。
注意点：内联函数不能递归，末尾不加分号(;)
例子：square函数计算

#include<iostream>

inline double square(double x){return x*x;}

int main()
{
	using namespace std;
	double a,b;
	double c = 13.0;
	a = square(5.0);
	b = square(4.5 + 7.5);
	cout << "a = "<<a<<" , b = "<<b<<"\n"; // a =25 b = 144
	cout << "c = "<<c; //c = 13
	cout << ", c squared = "<<square(c++)<<"\n"; // c = 14*14=169
	cout << "Now c = "<<c<<"\n"; //c=14
	return 0;
}

内联函数和常规函数一样，都是按值来传递参数。
在将值传递给函数square之前，程序自动把传入值强制转换为double类型。

1.4 内联和宏
inline是C++新增特性。
在C语言中使用预处理器#define来提供宏。————> 内联代码的原始实现。

#define SQUARE(x) x*x

此时不是通过传递参数实现，而是通过文本替换来实现。
宏的缺点：不能按值传递。

2. 引用变量
引用：已定义变量的别名。
主要用途：用作 函数的形参。通过引用变量用作参数，函数将使用原始数据，而不是使用副本。

2.1 创建引用变量
C和C++中使用 地址符（&） 来指示变量的地址。用来声明引用。 （符号重载）

int rats;
int & rodents = rats; // &不是地址运算符，是类型标识符的一部分。

引用必须在声明引用时将其初始化，而不是类似指针，先声明，再赋值。

引用更接近 const指针，必须在创建时进行初始化，变量关联后，就无法更改。

2.2 引用用作函数参数
引用传递：当引用被用作函数参数时，使得函数中的变量名成为调用程序中的变量的别名。
允许被调用的函数能够访问调用函数中的变量。

按值传递：被调用函数使用调用程序的值的拷贝。
C语言中改用按指针传递的方式避开按值传递的限制。

使用和访问原始数据的方法：按引用传递和传递指针。

当左值引用参数是 const时，会生成临时变量的两种情况：
左值参数：可被引用的数据对象。
实参的类型正确，但不是左值。
实参的类型不正确，但可转换为正确的类型。
尽可能使用const

使用const可以避免无意中修改数据的编程错误
使用const使函数能够处理const和非const实参 ，否则只能接受非const数据。
使用const引用使函数能够正确生成并使用临时变量(如果实参和引用参数不匹配，c++将生成临时变量)。

C++11 引入 右值引用，可指向右值，使用 && 来声明。
代码例子 

#include<iostream>

using namespace std;

double cube(double a);
double refcube(const double &ra); // 使用const的目的：防止引用的参数被修改。

int main()
{
    double x = 3.0;
    cout<<x<<" 的立方为: "<<cube(x)<<endl;
    cout<<x<<" 的立方为："<<refcube(x)<<endl;
    return 0;
}
double cube(double a)
{
    return a*a*a;
}
double refcube(const double &ra)
{
    return ra*ra*ra;
}

注意：如果函数调用的参数不是左值或与相对应的const引用参数的类型不匹配，则C++将创建类型正确的匿名变量，将函数调用的参数的值传递给匿名变量，并让参数来引用该变量。

2.3 结构引用
引用适合结构和类（用户自定义类型，非基本的内置类型）。
引入引用的目的：用于用户自定义类型，而不是基本的内置类型。
使用 结构引用参数的方式 与基本变量引用 相同，只需在声明结构参数时使用 引用运算符& 即可。
代码例子 

#include<iostream>
#include<string>

using namespace std;

/*创建结构*/
struct free_throws
{
    string name;
    int made;
    int attempts;
    float percent;
};

/*声明函数原型*/
void display(const free_throws & ft); 
void set_pc(free_throws & ft);
free_throws & accumulate(free_throws & target,const free_throws & source);

int main()
{
    /*对部分初始化，其余部分设置为0*/
    free_throws one = {"ifelsa branch",13,14};
    free_throws two = {"Andor Knott",10,16};
    free_throws three = {"Minnie Max",7,9};
    free_throws four = {"Whily Looper",5,9};
    free_throws five = {"Long Long",6,14};
    free_throws team = {"Throwgoods",0,0};

    /*不做初始化*/
    free_throws dup;

    set_pc(one); /*set_pc中的ft为引用，按值传递不可行*/
    display(one); /*使用const引用参数，可以使用按值传递结构，但是使用引用的好处：可以节省时间和内存*/
    accumulate(team,one); /*第一个参数：引用 ———— 可修改，第二个参数：const引用*/
    display(team);

    /*使用返回值作为参数*/
    display(accumulate(team,two));
    accumulate(accumulate(team,three),four);
    display(team);

    /*使用返回值进行赋值*/
    dup = accumulate(team,five); /*添加five的数据给dup*/
    cout<<"Displaying team:\n";
    display(team);
    cout<<"Displaying dup after assignment:\n";
    display(dup);
    set_pc(four);

    /*ill-advised assignment*/
    
    /*将five的数据添加到dup中，再使用four的内容覆盖dup的内容。返回类型是const，不可修改，所以赋值不合法。*/
    accumulate(dup,five) = four;   
    cout<<"Displaying dup after ill-advised assignment:\n";
    display(dup);
    return 0;
}

/*输出展示*/
void display(const free_throws & ft)
{
    cout<<"Name : "<<ft.name<<'\n';
    cout<<"Made : "<<ft.made<<'\t';
    cout<<"Attempts : "<<ft.attempts<<'\t';
    cout<<"Percent : "<<ft.percent<<'\n';
}

/*计算*/
void set_pc(free_throws & ft)
{
    if(ft.attempts!=0)
        ft.percent = 100.0f * float(ft.made)/float(ft.attempts);
    else
        ft.percent = 0;    
}

/**/
free_throws & accumulate(free_throws & target,const free_throws & source) /*const类型，所以不可修改*/ 
{
    target.attempts += source.attempts;
    target.made += source.made;
    set_pc(target);
    return target;
}

2.4 返回引用时的注意事项
避免返回函数终止时不再存在的内存单元引用。原因：函数运行完毕后将不存在。
杜绝使用临时变量的引用

const free_throws & clone2(free_throws &ft)
{
	free_throws newguy; 
	newguy = ft; // 拷贝
	return newguy; //返回拷贝引用，返回一个指向临时变量newguy的引用，函数执行完毕后则不存在。
}

解决方法：
1.返回一个作为参数传递给函数的引用。作为参数的引用将指向调用函数使用的数据，返回的引用也随之指向所使用的数据。
2.使用new来分配新的存储空间，使得返回指向该内存空间的指针。👉小缺点：会忘记使用 delete 来释放内存。

改进后：

const free_throws & clone(free_throws &ft)
{
	free_throws *pt; //使用指针指向结构，所以*pt可直接代表 free_throws这个结构
	*pt = ft; //拷贝信息
	return *pt; //返回
}

如果返回一个结构，而不是指向结构的引用，将整个结构复制到一个临时变量，再将临时变量拷贝。效率比其他传递方式高。

2.5 对象、继承和引用
继承：将语言的特性从一个类传递给另一个类。

继承的特征：派生来继承了基类的方法，基类引用可以指向派生类对象，而无需进行强制类型转换。
ostream是基类
ofstream是派生类

2.7 何时使用引用参数
使用引用参数的两个主要原因
程序员能修改调用函数中的数据对象。
通过传递引用而不是整个数据对象，提高程序的运行速度。（当数据对象（结构和类对象）较大时很重要）

对于使用传递的值而不作修改的函数
数据对象很小，如内置数据类型或小型结构，按值传递；
数据对象是数组，则使用指针，因为这是唯一的选择，并将 指针声明为指向 const 的指针；
数据对象是较大的结构，则使用 const 指针或 const 引用，可以 节省复制结构所需的时间和空间；
数据对象是类对象，则使用 const 引用。传递类对象参数的标准方式是 按引用传递。

对于修改调用函数中数据的函数
数据对象是内置数据类型，则使用指针；
数据对象是数组，则只能使用指针；
数据对象是结构，则使用引用或指针；
数据对象是类对象，则使用引用。

3. 默认参数
定义：指当函数调用中省略了实参时自动使用的一个值。
设置默认值的方法：通过函数原型将值赋给原型中的参数。例left() 原型：

char *left(const char *str,int n = 1);

对于带参数列表的函数，必须从右向左添加默认值（要为某个参数设置默认值，必须为其右边的所有参数提供默认值）。

int harpo(int n,int m = 4 , int j = 5); //VALID
int chico(int n ,int m = 6,int j); // INVALID

实参按 从左向右 的顺序依次被赋给相应的形参，而不能跳过任何参数。

beeps = harpo(3, ,8); // 不允许

默认参数的好处：减少要定义的析构函数、方法以及方法重载的数量*。
注意：只有原型指定了默认值，函数定义与没有默认参数时完全相同。

#include<iostream>
const int ArSize = 80;
char *left(const char * str,int n = 1);
int main()
{
    using namespace std;
    char sample[ArSize];
    cout <<"Enter a string : \n";
    cin.get(sample,ArSize);
    char * ps = left(sample,4);
    cout << ps << endl;
    delete [] ps;
    ps = left(sample);
    cout << ps << endl;
    delete [] ps;
    return 0;
}
char *left(const char *str,int n)
{
    if(n<0)
        n = 0;
    char *p = new char[n+1];
    int i;
    for(i = 0;i < n && str[i];i++)
        p[i] = str[i];
    while(i<=n)
        p[i++] = '\0';
    return p;
}

设置新字符串程度的方法：使用 strlen() 函数。

int len = strlen(str);
n = (n < len)?n:len
char *p = new char[n+1];

C程序倾向于运行速度快，代码简洁。
C++追求可靠性。

4. 函数重载（polymorphism）
默认参数可以使用不同数目的参数调用同一个函数。
术语多态（polymorphism） 指多种形式，函数多态允许函数使用多种形式。
术语函数重载 指可以有多个同名的函数，则对名称进行重载。
函数多态（函数重载）可使用多个同名的函数。
函数重载的关键是函数的参数列表 ---> 函数特征标。
C++允许定义名称相同的函数，条件是特征标不同。
编译器在检查函数特征标时，将把类型引用和类型本身视为同一个特征标。
匹配函数时，不区分const 和非const变量。
注意：真正让函数能够进行重载的是：特征标。

4.1 左值引用和右值引用（自我扩展补充）
C++ 11 中新增特性 
区分左值和右值的方法：查看能否对其进行取地址操作。
可取地址，位于等号左边 ---> 左值
不可取地址，位于等号右边 ---> 右值
参考文章总结：有地址的变量就是左值，没有地址的字面值、临时值就是右值。
左值引用 能指向左值，不能指向右值的就是左值引用。

int a = 5;
int &ref_a = a; // 左值引用指向左值，编译通过
int &ref_a = 5; // 左值引用指向了右值，会编译失败

引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值。 但const左值引用是可以指向右值

const int &ref_a = 5;

原因：const左值引用不会修改指向值，因此可以指向右值。

右值引用
右值引用的标志是&&。
右值引用专门为右值而生，可以指向右值，不能指向左值

int &&ref_a_right = 5; // ok
 
int a = 5;
int &&ref_a_left = a; // 编译不过，右值引用不可以指向左值
 
ref_a_right = 6; // 右值引用的用途：可以修改右值

被声明出来的左、右值引用都是左值。 因为被声明出的左右值引用是有地址的，也位于等号左边。

4.2 何时使用函数重载？
函数重载不可滥用。仅当函数基本上执行相同的任务，但使用不同形式的数据时，才应采用函数重载。

5. 函数模版
5.1 重载的模板
函数模板是通用的函数描述，使用泛型（可用具体的类型替换）来定义函数。所以也叫做通用编程。
建立一个模板，关键字 template 和 typename 是必需，除非使用关键字class代替typename，必须使用 尖括号<>。

template <typename T> /*C++98 标准时添加关键字 typename*/
template <class T> /*C++98之前使用class*/

Tips：如果需要多个将同一种算法用于不同类型的函数，请使用模板。如果不考虑向后兼容的问题，并愿意键入较长的单词，则声明类型参数时，应使用关键字typename而不是class。
注意：函数模板不能缩短可执行程序。
模板重载和函数重载类似。

5.2 模板的局限性
模板函数也会有一些无法处理的某些类型。

template <class T> /*等于 template <typename T>*/
void f(T a,T b)
{
    a=b; /*如果T为数组时，假设不成立*/
    if(a > b) /*如果T为结构时，假设不成立*/
}

5.3 显式具体化
当编译器找到与函数调用匹配的具体化定义时，将使用该定义，而不再寻找模板。

C++98标准使用的方法
对于给定的函数名，可以有非模板函数、模板函数和显式具体化模板函数以及他们的重载版本。
显示具体化的原型和定义应以template<>打头，并通过名称来指出类型。
具体化 优先于常规模板，而非模板函数优先于具体化和常规模板。

显式具体化的格式：

template <> void Swap<int>(int&,int&)

5.4 实例化和具体化
在代码中包含函数模板本身并不会生成函数定义，只是一个用于生成函数定义的方案。
隐式实例化：编译器在使用模板事会为特定类型生成函数定义时，即可实现模板实例。
显式实例化：直接告知编译器创建特定的实例。

/*语法：声明所需的类 ----> 用符号 <> 符号指示类型，并在声明前加上关键字template*/
template void Swap<int>(int,int); /*显式实例化*/

注意：显式具体化声明在关键字template后包含<>，而显式实例化没有。
警告：不要试图在同一个文件（或转换单元）中使用同一种类型的显式实例和显式具体化，否则会出错。
隐式实例化、显式实例化和显式具体化统称为具体化。

5.5 编译器选择使用哪个函数版本
重载解析：决定为函数调用使用哪一个函数定义的过程。

解析的过程
创建候选函数列表，包含被调用函数名称相同的所有函数
使用候选函数列表创建可执行函数列表，这些都是参数数目正确的函数，为此有一个隐式转换序列，其中包括实参类型和相应的形参类型完全匹配的情况。
确定是否有最佳可执行函数，如果有则调用，没有则报错
在实际场景下，只考虑特征标，不考虑返回类型。

第九章
1. 单独编译
C++鼓励将组件函数放在独立的文件中。可单独编译文件，然后将其链接成可执行的程序。
C++编译器既编译程序，也管理链接器。
C++都将一些结构声明或结构函数原型都放在头文件中，然后使用 #include 指令来管理头文件。（注意：不是包含源代码文件）
不要将函数定义或变量声明放到头文件中，简单场景无问题，大型场景会引发问题 。

头文件中包含的内容
函数原型
使用#define或const定义的符号常量
结构声明
类声明
模板声明
内联函数
在同一个文件中只能将同一个头文件包含一次。例如，可能使用包含了另外一个头文件的头文件，为了避免这种情况，可以采用以下一种技术#ifndef #define…..#endif。

2. 存储持续性、作用域和链接性
C++中使用了四种不同的方案来存储数据，它们的区别在于数据保留在内存中的时间。

2.1 作用域和链接
作用域描述了名称在文件的多大范围可见。
链接性描述了名称如何在不同单元间共享。链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享。

C++变量的作用域的种类
局部的变量只在定义它的代码块使用（函数体）
全局（文件作用域）的变量在定义位置到文件结尾直接都可用。
自动变量的作用域为局部。
静态变量的作用域取决于如何被定义。
函数原型中的名称只在包含参数列表的括号内可用
类中声明的成员的作用域为整个类。
名称空间中声明的变量作用域为整个名称空间。

2.2 自动存储持续性
在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。程序执行其所属的函数或代码块时被创建，在执行完后被释放。自动变量的名称没有链接性，因为不能共享。
作用域为局部，没有链接性。

2.3 静态存储持续性
在函数定义外定义的变量和使用关键字static定义的变量的存储持续性为静态，它们在程序整个运行过程中都存在.

提供了3种链接性：
外部链接性：代码块的外面声明
单定义规则：变量只能有一次定义。

C++提供了两种变量声明：
定义声明：给变量分配存储空间。
引用声明：不给变量分配存储空间（引用已有的变量）。引用声明使用关键字extern，且不进行初始化。
如果多个文件中要使用外部变量，只需一个文件中包含该变量的定义（单定义规则），使用该变量的其他文件中，都必须使用关键字extern 声明。
内部链接性：在代码块的外面声明，且使用static限定符。
在其所属的文件中使用。
无链接性：代码块内使用，且使用static限定符。
一般是在函数内使用，尽管函数之间多次被调用，其值不会发生变化。
所有静态持续变量在整个程序执行期间都存在。
除默认的零初始化外，可对静态变量进行常量表达式初始化和动态初始化。

2.4 线程存储持续性（C++11特性）
在多核处理器中，这些CPU可以同时处理多个执行任务，这让程序能够将计算机放在可并行处理的不同线程中，如果变量是使用关键字thread_local声明的，则其生命周期与所属的线程一样长。

2.5 动态存储持续性
用new运算符分配的内存一直存在，直到使用delete运算符将其释放或程序结束为止，这种内存有时被称为自由存储或堆。

2.6 说明符和限定符

存储说明符
auto（C++11中不是说明符）：用于自动类型推断
register：声明中指示寄存器存储，C++11中显式指出变量是自动。
static：内部链接性，作用域为整个文件的声明中。主要使用静态局部变量。
extern：引用声明，声明引用在其它地方定义的变量。
thread_local（C++11新增）：指出变量的持续性与其所属线程的持续性相同。
mutable：即使结构（或类）变量为const，其某个成员也可以被修改。
volatile：程序代码没有对内存单元进行修改，其值可能发生变化。

2.7 存储方案和动态分配
使用C++运算符new（或C函数malloc()）分配的内存，称为动态内存。
动态内存由new 和 delete 控制。而不是作用域和链接性规则控制。
编译器的三块独立内存：静态变量、自动变量、动态存储。
使用new运算符初始化 如果为内置的标量类型分配存储空间并初始化，可在类型名后面加上初始值，将其用括号括起。

int *pi = new int (6);

要初始化常规结构或数组，需要使用大括号的列表初始化。
new失败时 早期返回空指针，现在会触发异常std::bad_alloc。
new和delete 运算符new和new[]分别调用如下函数：

void * operater new(std::size_t);
void * operater new[](std::size_t);

称为分配函数，对应的释放函数如下：

void operator delete(void *);
void operator delete[](void *);

定位new 运算符
new的两个功能：
在堆中找到足以满足的内存块。
指定要使用的位置（定位特性）。
使用new定位特性，需要包含头文件new。

3. 名称空间
在C++中，名称可以是变量、函数、结构、枚举、类以及类和结构的成员。
解决名称空间冲突的问题。

3.1 传统的C++名称空间
声明区域：声明所在区域。
潜在作用域：变量的潜在作用域从声明点开始，到其声明区域的结尾。

3.2 新的名称空间特性
通过定义一个新的声明区域来创建命名的名称空间 ---- 目的：提供一个声明名称的区域。避免名称空间中的名称之间发生冲突。
默认情况下，名称空间中的声明的名称是外部链接。
名称空间可以是全局，也可是另一个名称空间，但不能是位于代码块中。

3.2.1 访问名称空间中的方法
通过作用域解析运算符::，使用名称空间来限定使用。
C++机制（using声明和using编译指令）来简化对于名称空间中的名称使用。
using声明：仅名称空间中的特定的名称可用，通过作用域解析运算符进行。
using编译指令：使整个名称空间中的名称可用。

using std::cout;

一般情况下，使用using声明比使用using编译指令更安全。
利用namespace来创建声明区域，用using关键字来使用。

4. 名称空间的一些指导原则
使用在已命名的名称空间中声明的变量，而不是使用外部全局变量或静态全局变量。
如果开发了一个函数库或类库；将其放在一个名称空间中。事实上，C++当前提倡将标准函数库 放在名称空间std中，这种做法扩展到了来自C语言中的函数。例如，头文件math.h 是与C语言 兼容的，没有使用名称空间，但C++头文件cmath应将各种数学库函数放在名称空间std中。实 际上，并非所有的编译器都完成了这种过渡。
仅将编译指令using作为一种将旧代码转换为使用名称空间的权宜之计。
不要在头文件中使用using编译指令。首先，这样做掩盖了要让哪些名称可用；另外，包含头文 件的顺序可能影响程序的行为。如果非要使用编译指令using,应将其放在所有预处理器编译指令  #include之后.
导入名称时，首选使用作用域解析运算符或using声明的方法。
对于using声明，首选将其作用域设置为局部而不是全局。