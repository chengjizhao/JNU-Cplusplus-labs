第九章 内存模型和名称空间
单独编译。
存储持续性、作用域和链接性。
定位（placement）new运算符。
名称空间。

9.1单独编译
和C语言一样，C++也允许甚至鼓励程序员将组件函数放在独立的文件中。可以单独编译这些文件，然后将它们链接成可执行的程序。（通常，C++编译器既编译程序，也管理链接器。）如果只修改了一个文件，则可以只重新编译该文件，然后将它与其他文件的编译版本链接。这使得大程序的管理更便捷。

9.2储存持续性、作用域和链接性
自动存储持续性：在函数定义中声明的变量（包括函数参数）的存
储持续性为自动的。它们在程序开始执行其所属的函数或代码块时
被创建，在执行完函数或代码块时，它们使用的内存被释放。
C++有两种存储持续性为自动的变量。
静态存储持续性：在函数定义外定义的变量和使用关键字static定义
的变量的存储持续性都为静态。它们在程序整个运行过程中都存
在。C++有3种存储持续性为静态的变量。
线程存储持续性（C++11）：当前，多核处理器很常见，这些CPU
可同时处理多个执行任务。这让程序能够将计算放在可并行处理的
不同线程中。如果变量是使用关键字thread_local声明的，则其生命
周期与所属的线程一样长。
动态存储持续性：用new运算符分配的内存将一直存在，直到使用
delete运算符将其释放或程序结束为止。这种内存的存储持续性为
动态，有时被称为自由存储（free store）或堆（heap）


9.3名称空间
在C++中，名称可以是变量、函数、结构、枚举、类以及类和结构的成员。当随着项目的增大，名称相互冲突的可能性也将增加。使用多个厂商的类库时，可能导致名称冲突。例如，两个库可能都定义了名为List、Tree和Node的类，但定义的方式不兼容。用户可能希望使用一个库的List类，而使用另一个库的Tree类。这种冲突被称为名称间问题。
·声明区域是可以在其中进行声明的区域。例如，可以在函数外面声明全局变量，对于这种变量，其声明区域为其声明所在的文件。对于在函数中声明的变量，其声明区域为其声明所在的代码块。
·变量的潜在作用域从声明点开始，到其声明区域的结尾。因此潜在作用域比声明
区域小，这是由于变量必须定义后才能使用。

C++新增了这样一种功能，即通过定义一种新的声明区域来创建命
名的名称空间，这样做的目的之一是提供一个声明名称的区域。一个名
称空间中的名称不会与另外一个名称空间的相同名称发生冲突，同时允
许程序的其他部分使用该名称空间中声明的东西。


总结
extern关键字用来声明变量，或者函数名以及对象名在其他文件中已经定义过，它通常只是起到一个说明的作用，只是告诉编译器这个变量来自其他文件，编译器会根据这个它提供的变量和名字在其他文件中查找。static关键字和未命名空间的作用相同，是文件级别的静态变量，也就是说它所定义的变量只能在使用它的文件中使用，而在其他文件中必须显示的包含它才可以使用（一般是使用#include包含static所在的文件）。static与extern的区别是：static是内部链接，extern是外部链接，static定义的变量只能在此变量的文件中使用，而extern则将它所声明的变量链接到其他文件，以便于链接器查找到此变量的定义部分。namespace只能在全局范畴内定义。
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
第十章

主要内容
过程性编程和面向对象编程。
类概念。
如何定义和实现类。
公有类访问和私有类访问。
类的数据成员。
类方法（类函数成员）。
创建和使用类对象。
类的构造函数和析构函数。
const成员函数。
this指针。
创建对象数组。
类作用域。
抽象数据类型

面向对象编程是一种特殊的设计程序的概念性方法，其特点有：抽象，封装和数据隐藏，多态，继承，以及代码可重用性。C++用类将上述特性组合到一起

10.1过程性编程和面向对象编程
采用过程性编程方法时，首先考虑要遵循的步骤，然后考虑
如何表示这些数据。采用OOP方法时，首先从用户的角度考虑对象——描述对象
所需的数据以及描述用户与数据交互所需的操作。完成对接口的描述
后，需要确定如何实现接口和数据存储。最后，使用新的设计方案创建
出程序。

10.2抽象和类
处理复杂性的方法之一是简化和抽象。将问题的本质特征抽象出来，并根据特征来描述解决方案。
指定基本类型完成了三项工作：
   决定数据对象需要的内存数量；
   决定如何解释内存中的位（long和float在内存中占用的位数相同，
   但将它们转换为数值的方法不同）；
   决定可使用数据对象执行的操作或方法。
C++中的类：
一般来说，类规范由两个部分组成。
类声明：以数据成员的方式描述数据部分，以成员函数（被称为方法）的方式描述公有接口。
类方法定义：描述如何实现类成员函数

实现类成员函数
定义成员函数时，使用作用域解析运算符（::）来标识函数所属的类；
类方法可以访问类的private组件。
其定义位于类声明中的函数都将自动成为内联函数。如果愿意，也可以在类声明之外定义成员函数，并使其成为内联函数。为此，只需在类实现部分中定义函数时使用inline限定符即可。


10.3 类的构造函数和析构函数
在初始化时，数据部分的访问状态是私有的，这意味着程序不能直接访问数据成员。您已经看到，程序只能通过成员函数来访问数据成员，因此需要设计合适的成员函数，才能成功地将对象初始化。一般来说，最好是在创建对象时对他进行初始化。

用构造函数创建对象后，程序负责跟踪该对象，直到其过期为止。析构函数完成清理工作。
构造函数是一种特殊的类成员函数，在创建类对象时被调用。构造函数的名称和类名相同，但通过函数重载，可以创建多个同名的构造函数，条件是每个函数的特征标（参数列表）都不同。另外，构造函数没有声明类型。通常，构造函数用于初始化类对象的成员，初始化应与构造函数的参数列表匹配。

10.4 this指针
有时候方法可能涉及到两个对象，在这种情况下需要使用C++的this指针。

10.5对象数组
用户通常要创建同一个类的多个对象。可以创建独立对象变量，就像本章前面的示例所做的，但创建对象数组将更合适。

10.6 类作用域
在类中定义的名称（如类数据成员名和类成员函数名）的作用域都
为整个类，作用域为整个类的名称只在该类中是已知的，在类外是不可
知的。因此，可以在不同类中使用相同的类成员名而不会引起冲突。

10.7 抽象数据类型
程序员常常通过定义类来表示更通用的概念。例如，就实现计算机专家们所说的抽象数据类型（abstract datatype，ADT）而言，使用类是一种非常好的方式。

总结

面向对象编程强调的是程序如何表示数据。使用OOP方法解决编程
问题的第一步是根据它与程序之间的接口来描述数据，从而指定如何使
用数据。然后，设计一个类来实现该接口。一般来说，私有数据成员存
储信息，公有成员函数（又称为方法）提供访问数据的唯一途径。类将
数据和方法组合成一个单元，其私有性实现数据隐藏。
通常，将类声明分成两部分组成，这两部分通常保存在不同的文件
中。类声明（包括由函数原型表示的方法）应放到头文件中。定义成员
函数的源代码放在方法文件中。这样便将接口描述与实现细节分开了。
从理论上说，只需知道公有接口就可以使用类。当然，可以查看实现方
法（除非只提供了编译形式），但程序不应依赖于其实现细节，如知道
某个值被存储为int。只要程序和类只通过定义接口的方法进行通信，程
序员就可以随意地对任何部分做独立的改进，而不必担心这样做会导致
意外的不良影响。
类是用户定义的类型，对象是类的实例。这意味着对象是这种类型
的变量，例如由new按类描述分配的内存。C++试图让用户定义的类型
尽可能与标准类型类似，因此可以声明对象、指向对象的指针和对象数
组。可以按值传递对象、将对象作为函数返回值、将一个对象赋给同类
型的另一个对象。如果提供了构造函数，则在创建对象时，可以初始化
对象。如果提供了析构函数方法，则在对象消亡后，程序将执行该函
数。
每个对象都存储自己的数据，而共享类方法。如果mr_object是对象
名，try_me( )是成员函数，则可以使用成员运算符句点调用成员函数：
mr_object.try_me( )。在OOP中，这种函数调用被称为将try_me消息发送
给mr_object对象。在try_me( )方法中引用类数据成员时，将使用
mr_object对象相应的数据成员。同样，函数调用i_object.try_me( )将访
问i_object对象的数据成员。
如果希望成员函数对多个对象进行操作，可以将额外的对象作为参
数传递给它。如果方法需要显式地引用调用它的对象，则可以使用this
指针。由于this指针被设置为调用对象的地址，因此*this是该对象的别
名。
类很适合用于描述ADT。公有成员函数接口提供了ADT描述的服
务，类的私有部分和类方法的代码提供了实现，这些实现对类的客户隐
藏。





