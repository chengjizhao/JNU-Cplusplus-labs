第九章内存模型和名称空间
9.1.单独编译
头文件中常包含的内容:
函数原型、使用#define或const定义的符号常量、结构声明、类声明、模板声明、内联函数
9.2.存储连续性、作用域和链接性
作用域：描述了名称在文件的多大范围内可见。
链接域：描述了名称如何在不同单元间共享。
作用域为局部变量只在定义它的代码块中可用。代码块是由花括号括起来的一系列语句。
静态持续变量:
编译器将分配固定的内存块来存储所有的静态变量，这些变量在整个程序执行期间一直存在。
静态存储持续变量有3种链接性:
外部链接性（可在其他文件中访问）
内部链接性（只能在当前文件中访问）
无链接性（只能在当前函数或代码块中访问）
外部链接性:
定义声明（简称定义），给变量分配存储空间
引用声明（简称声明），不给变量分配存储空间，它引用已有的变量。引用声明使用关键字extern，不进行初始化，否则报错多重定义。
内部链接性:
将static限定符用于作用域为整个文件的变量时，该变量的链接性将为内部的。
两个文件声明的常规外部变量相同，静态变量将隐藏常规外部变量
无链接性:
将static限定符用于在代码块中定义的变量，为无链接性的静态局部变量。
const限定符
限定符volatile：编译器不会对该变量进行优化，从而可以提供对特殊地址的稳定访问。
mutable：即使结构体或者类为const类型，但被mutable修饰的成员也可以被修改。
动态内存由运算符new和delete控制，而不是由作用域和链接性规则控制。
通常，编译器使用三块独立的内存
用于存放静态变量
用于自动变量
用于动态存储
定位 new 运算符
定位new运算符，能够在指定内存地址存放变量。不管它是否已经被使用，新值直接覆盖在旧值上面。
第十章 对象和类
10.1 过程性编程和面向对象编程
面向过程首先考虑要遵循的步骤；然后考虑如何表示这些数据。
面向对象首先从用户角度考虑对象，描述对象的所需的数据以及描述用户与数据交互所需的操作。
10.2 抽象和类
C语言中有基本数据（int float char 指针）类型完成如下工作：
决定数据对象需要的内存数量；决定内存中的位（不同类型占用不同的内存位数）；决定可使用数据对象执行的操作或方法。
C++对结构进行了扩展，结构和类的唯一区别是：结构默认访问是public,而类是private。
定义位于类声明中的函数都将自动成为内联函数。
创建的每个对象都有自己的存储空间，用于存储其内部变量和类成员。但同一个类的所有对象共享同一组类方法。
10.3 类的构造和析构函数
构造函数初始化对象，析构函数释放对象空间。
构造函数没有声明类型。构造函数被用来构建对象，而不能通过对象调用。
当仅当没有定义任何构造函数时，编译器才会提供默认构造函数。
定义默认构造函数有两种方式（不可同时使用）：没有参数、提供参数并给所有参数设置默认值。
析构函数调用时机：静态存储类，程序结束时；自动存储类，执行完代码块；new，使用 delete 时。
在默认情况下，将一个对象赋给同类型的另一个对象时，C++将源对象的每个数据成员的内容复制到目标对象中的相应的数据成员中。
只要类方法不修改调用对象，就应将其声明为 const。
10.4 this指针
this指针，指的是对象本身。
10.5 对象数组
和正常数组一样，也可以创建类的多个对象，如Stock st[4];创建了四个对象的数组。
10.6 类的作用域
类的成员函数的定义在函数前用类名::区分。
C++ 11 允许在类中定义的枚举类型和静态方法定义一个常量。
如：enum {MAX = 10} 等价于：static const int MAX = 10;
使用枚举或关键字 static 来解决类中需要特定的值。
10.7 抽象数据类型
类很具体，也可以定义抽象数据类型，如：
typedef unsigned long Item;
Item items[5];
