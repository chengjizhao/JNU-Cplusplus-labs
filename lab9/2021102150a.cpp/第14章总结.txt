14章 c++中的代码重用

has-a关系。
包含对象成员的类。
模板类valarray。
私有和保护继承。
多重继承。
虚基类。
创建类模板。
使用类模板。
模板的具体化。

C++的一个主要目标是促进代码重用。公有继承是实现这种目标的机制之一，但并不是唯一的机制。 本章介绍了其他方法实现代码重用：使用一个本身是另一个类的对象的类成员，成为“包含、组合或层次化”；另一种是使用私有或保护继承。

14.1 包含对象成员的类

valarray类是由头文件valarray支持的。顾名思义，这个类用于处理数值（或具有类似特性的类），它支持诸如将数组中所有元素的值相加以及在数组中找出最大和最小的值等操作。

使用valarray类来声明一个对象时，需要在标识符valarray后面加上一对尖括号，并在其中包含所需的数据类型：
	valarray<int> q_values

14.2 私有继承
C++还有另一种实现has-a关系的途径——私有继承。使用私有继
承，基类的公有成员和保护成员都将成为派生类的私有成员。这意味着
基类方法将不会成为派生对象公有接口的一部分，但可以在派生类的成
员函数中使用它们。

14.3保护继承
保护继承是私有继承的变体。保护继承在列出基类时使用关键字protected：
使用保护继承时，基类的公有成员和保护成员都将成为派生类的保
护成员。和私有私有继承一样，基类的接口在派生类中也是可用的，但
在继承层次结构之外是不可用的。

当从派生类派生出另一个类时，私有
继承和保护继承之间的主要区别便呈现出来了。使用私有继承时，第三
代类将不能使用基类的接口，这是因为基类的公有方法在派生类中将变
成私有方法；使用保护继承时，基类的公有方法在第二代中将变成受保
护的，因此第三代派生类可以使用它们。

14.3多重继承
多重继承指的是有多个直接基类的继承，表示的是is-a关系

为了解决多重继承可能产生的二义性等问题，引入“虚基类”的技术。
虚基类使得从多个类（它们的基类相同）派生出的对象只继承一个
基类对象。
如果一个类通过多种途径继承了一个非虚基类，则该类从每种途径
分别继承非虚基类的一个实例。

14.4 类模板
继承（公有、私有或保护）和包含并不总是能够满足重用代码的需
要。与其编写新的类声明，不如编写一个泛型（即独立于类型的）栈，然后将具体的类型作为参数传递给这个类。这样就可以使用通用的代码生成存储不同类型值的栈。

仅在程序包含模板并不能生成模板类，而必须请求实例化。为此，
需要声明一个类型为模板类的对象，方法是使用所需的具体类型替换泛
型名。

14.5 总结
C++提供了几种重用代码的手段。第13章介绍的公有继承能够建立
is-a关系，这样派生类可以重用基类的代码。私有继承和保护继承也使
得能够重用基类的代码，但建立的是has-a关系。使用私有继承时，基类
的公有成员和保护成员将成为派生类的私有成员；使用保护继承时，基
类的公有成员和保护成员将成为派生类的保护成员。
还可以通过开发包含对象成员的类来重用类代码。这种方法被称为
包含、层次化或组合，它建立的也是has-a关系。与私有继承和保护继承
相比，包含更容易实现和使用，所以通常优先采用这种方式。
多重继承（MI）使得能够在类设计中重用多个类的代码。私有MI
或保护MI建立has-a关系，而公有MI建立is-a关系。MI会带来一些问
题，即多次定义同一个名称，继承多个基类对象。可以使用类限定符来
解决名称二义性的问题，使用虚基类来避免继承多个基类对象的问题。
但使用虚基类后，就需要为编写构造函数初始化列表以及解决二义性问
题引入新的规则
类模板使得能够创建通用的类设计，其中类型（通常是成员类型）
由类型参数表示。