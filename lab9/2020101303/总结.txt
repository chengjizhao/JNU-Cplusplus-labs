第十四章 C++中的代码重用
包含对象成员的类为表示类中的组件提供了方便的途径。
valarray类是由头文件valarray支持的，这个类用于处理数值（或具有类似特性的类），它支持诸如将数组中所有元素的值相加以及在数组中找出最大和最小的值等操作。
valarray被定义为一个模板类，能够处理不同数据类型。声明方式：valarray<数据类型> 名称，eg:valarray<int> q_values。
创建valarray对象时可以使用列表初始化。
valarray类的方法：
  1、operator[]():访问各个元素；
  2、size():返回包含的元素总数；
  3、sum():返回所有元素的总和；
  4、max():返回最大的元素；
  5、min():返回最小的元素。
使用公有继承时，类可以继承接口，可能还有实现（基类的纯虚函数提供接口，但不提供实现）。获得接口是is-a关系的组成部分。而使用组合，类可以获得实现，但不能获得接口。不继承接口是has-a关系的组成部分。
使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。这意味着基类方法将不会成为派生类对象公有接口的一部分，但可以在派生类的成员函数中使用它们。
使用私有继承，类将获得实现但不获得接口；而公有继承将同时让派生类继承接口和实现。
使用私有继承时，只能在派生类内部使用基类的方法。如果希望基类工具是公有的，则可以在派生类中创建一个新的公有方法，这个公有方法是调用派生类内部私有的基类方法。
保护继承使用关键字protected：基类的公有成员和保护成员都成为派生类的保护成员，即内部可访问，在继承层次结构之外不可用。
MI描述的是有多个直接基类的类。
在多重继承中, 派生类会继承多个基类的成员函数和成员变量。与单一继承类似，只是在类名后面可以通过逗号分隔添加多个基类名。多继承的类具有多个父类，因此要考虑其访问控制，以确保派生类可以访问正确的基类成员。
多个基类中如果出现成员函数或成员变量名称相同，就会出现命名冲突的问题。 解决方法是使用作用域解析运算符(::)或者在派生类中覆盖基类中的成员函数。
虚基类使得从多个类派生出的对象只继承一个基类对象，实现方法是在继承时使用virtual关键字修饰基类（virtual与public次序无关紧要）。
同时继承多个虚基类时，不会多次导入重复的基类的基类，而是只保留一个版本；而同时继承多个非虚基类时，重复的部分会机械的重复继承。
在构造函数的使用上，虚继承和非虚继承有不同点：前者的构造函数，需要在初始化成员参数列表中直接对单拷贝的基类初始化，而后者只需要对直接的基类在初始化成员参数列表中逐个调用构造函数。
在 C++ 中，类模板可以让我们写出可以处理多种数据类型的通用类。类模板定义了一个通用的类模板，其中涉及的数据类型可以用作参数进行推导，以最终生成特定的类或函数。
类模板的定义方式与函数模板类似，使用 template 关键字加上类型参数列表来定义。类型参数列表中可以有多个类型参数，每个参数可以用于指定可以用在类中的不同类型。
使用模板类的方式与使用普通类基本相同，只需要在类名后面加上 <> 并指定类型参数即可。
在模板类中，也可以定义非类型参数，非类型参数指的是模板参数不是类型，而是常量表达式，它可以是整数、枚举、指针或引用。非类型参数可以在编译时进行计算，并使用它来定义模板类的行为。
类模板与函数模板相似，因为可以有隐式实例化、显式实例化和显式具体化。
模板类声明也可以有友元，分三类：非模板友元；约束模板友元，即友元的类型取决于类实例化时的类型；非约束模板友元，即友元的所有具体化都是类的每一个具体化的友元。

虚基类背后的实现机制：
假设类Bottom继承类Left和Right，而Left和Right均继承自Top，那么如果Top中有成员变量或虚函数，它们可能会被Bottom继承两次，引入二义性。
为了解决菱形继承问题，引入了虚基类的概念。通过将A定义为虚基类，只会有一个Top的实例被共享，在类Bottom中只有一个Top子对象。
每个类都有一个虚表，其中存储了该类的虚函数的指针。虚基类中的虚函数也会在虚表中有相应的位置。对于虚基类，编译器会创建一个虚继承表，用于跟踪虚基类在派生类中的偏移量。这个表确保不同派生类中共享的虚基类只有一个实例。派生类的构造函数和析构函数只会调用一次虚基类的析构函数。
因为虚基类引起共享子对象，共享发生之前它们就应该存在才有意义。所以子对象的初始化顺序按如下的规则递归地进行：
  1、所有虚基类子对象，按照它们在类定义中出现的位置，从上到下、从左到右初始化。
  2、非虚基类按通常顺序初始化。
  3、所有的成员对象按声明的顺序初始化。
  4、完整的对象的构造函数执行。