第九章 内联函数
一、
    C++中使用预处理器宏存在两个问题，一个问题在C中也存在：宏看起来像一个函数调
用，但并不总是这样。这样就隐藏了难以发现的错误。第二个问题是C++特有的：预处理器
不允许访问类的成员数据。这意味着预处理器宏不能用作类的成员函数。
    常见错误：
	例一：
	写法一 #define F (x) (x+1)
	写法二 #define F(x)  (x+1)
    法一在调用函数时容易出现微妙的错误，因为F和(x)之间有空格
若调用时写F(1)，会出现不是我们希望的结果，而法二在调用时可以
在F和(x)间加空格而没有错误；
    例二：
	由于运算符有先后顺序，有时候要在宏的参数外加括号，保证参数的
求值正常。然而，有时候就算加了括号，
    如：#define BAND(x) ((x)>5&&(x)<10 ? (x) : 0)
若调用时写的是BAND(++a),则++a在判断中，会被执行三次，不是我们
希望的结果

二、内联函数
   宏的概念是作为内联函数来实现的，而内联函数无论从那一方面上说都是真正的函数。内联函数能够像普通函数一样具有我们所有
期望的任何行为。惟一不同之处是内联函数在适当的地方像宏一样展开，所以不需要函数调用的开
销。因此，应该（几乎）永远不使用宏，只使用内联函数。
   ***任何在类中定义的函数自动地成为内联函数，但也可以在非类的函数前面加上inline关键字使之成为内联函数。但为了使之有效，必须使函数体和
声明结合在一起，否则，编译器将它作为普通函数对待。
   例： inline int plusOne(int x) {...};
   ***一般应该把内联定义放在头文件里。当编译器看到这个定义时，它把函数类型（函数名+返回
值）和函数体放到符号表里。在头文件中，内联函数处于一种特殊状态，因
为在头文件中声明该函数，所以必须包含头文件和
该函数的定义，这些定义在每个用到该函数的文件
中，但是不会出现产生多个定义错误的情况（不
过，在任何使用内联函数地方该内联函数的定义都
必须是相同的）。
   内联函数使用之访问函数，其实就是外部访问内部private的接口；
   访问函数可分访问器get和修改器set；（构造函数）
   小函数作为内联函数工作是理想的，两个最大的函数仍旧保留为非内联函数，因为要是把它们作为内联使用的话，很可能在
性能上得不到什么改善。
    ***编译器遇到内联函数：
	假如所有的函数类型信息符合调用的上下文的
话，内联函数代码就会直接替换函数调用，这消除
了调用的开销，也考虑了编译器的进一步优化。假
如内联函数也是成员函数，对象的地址（this）就
会被放入合适的地方，这个动作当然也是预处理器
不能完成的。
    ***有两种编译器不能执行内联的情况。假如函数太复杂，编译器将不能执行内联。
	1、一般地，任何种类的循环都被认为太复杂而不扩为内联函数。循环在函数里可能比调用要花费更多的时间。
假如函数仅由简单语句组成，编译器可能没有任何内联的麻烦，但假如函数有许多语句，调用函数的开销将比执行函数体的开销少多
记住，每次调用一个大的内联函数，整个函数体就被插入在函数调用的地方，所以很容易使代码膨胀！！！
    2、假如要显式地或隐式地取函数地址，编译器也不能执行内联。因为这时编译器必须为函数代码分
配内存从而产生一个函数的地址。但当地址不需要时，编译器仍将可能内联代码。

三、向前引用
int f()const{return g() +1;)
int g()const{return i;)
函数f（）调用g（），但此时还没有声明
g（）。这也能正常工作，因为C++语言规定：只
有在类声明结束后，其中的内联函数才会被计算。
如果g（）反过来调用f（），就会产生
递归调用，这对于编译器来说太复杂而不能执行内
联。

四、减少混乱（这部分没太看懂）




C++Prime
14章
C++提供了几种重用代码的手段。
无论使用哪种继承，基类的公有接口都将成为派生类的内部接口。这有时候被称为继承实现但并不继承接口，
因为派生类对象不能显式地使用基类的接口。因此，不能将派生对象看作是一种基类对象，由于这个原因，
在不进行显式类型转换的情况下，基类指针或引用将不能指向派生类对象。
还可以通过开发包含对象成员的类来重用类代码。这种方法被称为包含、层次化或组合，它建立的也是
has-a 关系。与私有继承和保护继承相比，包含更容易实现和使用，所以通常优先采用这种方式。
多重继承(MI)使得能够在类设计中重用多个类的代码。私有 M或保护 MI建立 has-a 关系而公有MI 建立 is-a 关系。