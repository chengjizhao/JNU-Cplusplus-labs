第14章是C++中的代码重用，内容包括has-a关系、包含对象成员的类、模板类valarray、私有和保护继承、多重继承、虚基类、创建类模板、使用类模板和模板的具体化，本章主要讲了如何促进代码重用。
首先讲了包含对象成员的类。在C++可以自己开发简单的类，当然C++也提供了一个适合的类valarray类，它是由头文件valarray支持的，用于处理数值或具有类似特性的类，支持诸如将数组中所有元素的值相加以及在数组中找到最大和最小的值等操作。在使用它声明一个对象时，需要在标识符valarray后面加上一对尖括号，并在其中包含所需的数据类型。
然后是私有继承，这是C++中另一种实现has-a关系的途径。使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员，只是基类方法不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。私有继承将对象作为一个未被命名的继承对象添加到类中，子对象即用来表示通过继承或包含添加的对象。保护继承是私有继承的变体，它在列出基类时使用关键字protected。使用保护继承时，基类的公有成员和保护成员都将成为派生类的保护成员，和私有继承一样基类的接口在派生类中也是可用的，但是在继承层级结构之外是不可用的。但是使用保护继承时，基类的公有方法在第二代中将编程受保护的，这和私有继承不同。
接下来是多重继承MI，它描述的是多个直接基类的类，私有MI或是保护MI建立has-a关系，公有MI表示的也是is-a关系。但是必须使用关键字public来限定每一个基类，否则编译器将认为是私有派生。但是MI会带来一些问题，多次定义同一个名称，继承多个基类对象。可以使用类限定符来解决名称二义性的问题，使用虚基类来避免这个问题，并且还需要为编写构造函数初始化列表和解决二义性问题引入新的规则。
最后介绍了类模板，它为生成通用的类声明提供了一种更好的方法，模板提供参数化类型，即能够将类型名作为参数传递给接收方来建立类或函数。首先是需要定义类模板，采用模板时，将使用模板定义替换原来的声明，使用模板成员函数替换原有的成员函数。然后再使用模板类，请求实例化，需要声明一个类型为模板类的对象，方法是使用所需的具体类型替换泛型名。模板具有多功能型，可以将用于常规类的技术用于模板类，模板类可用作基类，也可以用作组件类，还可以用作其他模板的类型参数。类模板和函数模板很相似，可以有隐式实例化、显式实例化和显式具体化，统称为具体化。