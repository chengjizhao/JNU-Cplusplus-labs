第十四章：
本章主要讲了has-a关系。包含对象成员的类。valarray 类是由头文件 valarray 支持的。顾名思义，这个类用于处理数值(或具有类似特性的类)，
支持诸如将数组中所有元素的值相加以及在数组中找出最大和最小的值等操作。valaray 被定义为一个模板类，以便能够处理不同的数据。
模板类valarrayo私有和保护继承。operator[]():让您能够访问各个元素size():返回包含的元素数。返回所有元素的总和。sum():返回最大的元素。
max():min():返回最小的元素。对于 has-a 关系来说，类对象不能自动获得被包含对象的接口是一件好事。例如，string 类将+运算符重载为将两个
字符串连接起来:但从概念上说，将两个 Student 对象接起来是没有意义的。这也是这不使用公有继承的原因之一。另一方面，被包含的类的接口部分
对新类来说可能是有意义的。C++还有另一种实现 has-a 关系的途径一私有继承。使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成
员。这意味着基类方法将不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。
多重继承。虚基类。创建类模板。MI可能会给程序员带来很多新问题。其中两个主要的问题是:从两个不同的基类继承同名方法:从两个或更多相关基类
那里继承同一个类的多个实例。为解决这些问题，需要使用一些新规则和不同的语法。因此，与使用单继承相比，使用 MI 更困难，也更容易出现问题。
由于这个原因，很多 C++用户强烈反对使用 MI，一些人甚至希望删除 MI:而喜欢 MI 的人则认为，对一些特殊的工程来说，MI很有用，甚至是必不可
少的;也有一些人建议谨慎、适度地使用 MI。有间接虚基类的派生类包含直接调用间接基类构造函数的构造函数，这对于间接非虚基类来说是非法的;
通过优先规则解决名称二义性。
使用类模板。C++的类模板为生成通用的类声明提供了一种更好的方法(C++最初不支持模板，但模板被引入后,就一直在演化，因此有的编译器可能不支
持这里介绍的所有特性)。模板提供参数化(parameterized)类型即能够将类型名作为参数传递给接收方来建立类或函数。例如，将类型名 int 传递给
 Oueue 模板，可以让编译器构造一个对int进行排队的Oueue类。
模板的具体化。类模板与函数模板很相似，因为可以有隐式实例化、显式实例化和显式具体化，它们统称为具体化(specialization)。模板以泛型的方
式描述类，而具体化是使用具体的类型生成类声明。


第九章：。C++中模拟接口继承常见的技术是从一个仅包含声明（没有数据和函数体）的接口类（interface class）派生一个类。除了析构函数以外，
这些声明都是纯虚函数。，C++仅仅提供了实现继承，这就意味着所有的内容总是继承自基类。这样做有很大的好处，因为它将使程序员从不得不在派生
类中实现所有的细节（正如前面的例子中所采用接口继承所做的事情）中解放出来。多重继承的一个共同用途包括使用混入类（mixin），这些混入类的
存在是为了通过继承来增加其他类的功能。混入类不能刻意地由它本身进行实例化。当从某个基类继承时，可以在其派生类中得到那个基类的所有数据成
员的副本。虚基类（Virtual Base Class）是C++中用于解决菱形继承问题（Diamond Inheritance Problem）的一种机制。当一个类同时继承自两个
或多个具有共同基类的类时，可能会出现二义性和数据冗余的问题。虚基类机制用于确保只有一个共同的基类实例，并解决这些问题。避免使用多重继承。
用户可以创建一个自己的类接口，并且采用多重继承方法产生一组新的派生类，这些新派生类派生自用户创建的类接口和已存在的类。