
一、线程概念
线程是程序执行流的最小单元，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但它可与同属一个进程的其他的线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程的多个线程之间相互共享内存和资源。
多线程是实现并发的一种有效手段，一个线程的结束通常意味着操作系统调度新的线程来接替其工作。C++中提供了许多与多线程编程相关的类库和工具，这些类库包括 `<thread>`、`<mutex>`、`<condition_variable>` 等。
二、线程创建
C++11 提供了 `std::thread` 类来创建和管理线程。下面是一个简单的例子：

```cpp
#include <iostream>
#include <thread>

void thread_function() {
    std::cout << "Hello from thread function!\n";
}

int main() {
    std::thread t(thread_function);  // 创建线程，并执行 thread_function 函数
    t.join();  // 等待线程结束
    return 0;
}
```
三、线程同步
当多个线程共享同一数据时，为了防止数据被多个线程同时读写导致数据的不一致性和线程间的竞争，需要进行线程同步。常见的线程同步技术包括：互斥量(mutex)、条件变量(condition variable)、读写锁等。
四、互斥锁(mutex)
互斥量是一种保护数据不被多个线程同时访问的同步机制。当一个线程需要访问共享数据时，需要先获取互斥量，如果互斥量已经被其他线程持有，则该线程会被阻塞，直到持有互斥量的线程释放互斥量。
五、条件变量(condition variable)
条件变量用于在多线程间传递信息或进行同步操作。它常常和互斥锁一起使用，一个线程可以等待某个条件变量的通知来决定是否继续执行，而其他线程可以通过改变这个条件来通知等待的线程。
六、读写锁(read-write lock)
读写锁是一种特殊的同步机制，允许多个线程同时读取共享数据，但在写入数据时则需要独占式的访问。这可以提高并发性能，特别是在读操作远多于写操作的情况下。
七、线程池(thread pool)
线程池是一种管理线程的方式，它预先创建一定数量的线程并保存在内存中，当有任务到来时，直接从线程池中取出空闲的线程进行处理，处理完成后线程回到线程池中等待下一个任务。这样可以避免频繁地创建和销毁线程，提高系统的性能。
八、线程优先级(thread priority)
每个线程都有优先级，优先级高的线程会优先执行。需要注意的是，虽然可以通过设置线程优先级来控制线程的执行顺序，但高优先级的线程并不能保证一定比低优先级的线程先执行。操作系统的调度策略也会影响实际的执行顺序。
九、线程局部存储(thread-local storage, TLS)
每个线程都有自己的数据副本，这些数据副本只对该线程可见。通过使用线程局部存储，可以在每个线程中保存自己的数据副本，而不会影响其他线程的数据。这可以用来解决一些多线程并发问题。
十、线程退出(thread exit)
当一个线程完成其任务时，它会退出。在 C++ 中，可以使用 `std::thread::join()` 或 `std::thread::detach()` 来处理线程的退出。`join()` 会阻塞当前线程，直到目标线程结束；`detach()` 则会让目标线程在后台运行，当目标线程结束时会自动清理资源。
std::thread：C++11标准库中提供的线程类，用于创建和管理线程。
std::mutex：互斥量，用于保护共享资源，防止多个线程同时访问。
std::lock_guard：互斥量保护器，用于自动管理互斥量的锁定和解锁。
std::condition_variable：条件变量，用于实现线程之间的同步