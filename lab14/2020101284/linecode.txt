多线程编程是一种并发编程的方式，允许程序同时执行多个线程，从而提高程序的性能和响应能力。以下是多线程编程的基础知识和相关概念：

线程（Thread）：线程是执行程序的最小单位，它包含了一个独立的执行序列。在多线程编程中，可以创建多个线程来并发执行任务。

并发（Concurrency）：并发是指多个任务在重叠的时间段内执行，通过合理的调度和资源共享，实现任务的交替执行。

互斥（Mutual Exclusion）：互斥是一种同步机制，用于保护共享资源，防止多个线程同时访问和修改共享数据，避免数据竞争和不确定的行为。

互斥量（Mutex）：互斥量是一种互斥的同步原语，提供了两个基本操作：lock（加锁）和unlock（解锁）。通过对互斥量进行加锁和解锁操作，可以实现对共享资源的互斥访问。

std::thread：std::thread 是 C++ 标准库中的一个类，用于创建和管理线程。通过创建 std::thread 对象，并传入要执行的函数或可调用对象，可以创建一个新的线程。

std::mutex：std::mutex 是 C++ 标准库中的一个类，用于提供互斥访问的功能。可以使用 std::mutex 对象对共享资源进行加锁和解锁操作。

std::lock_guard：std::lock_guard 是 C++ 标准库中的一个类，用于提供对互斥量的自动加锁和解锁。std::lock_guard 对象的生命周期与作用域绑定，在作用域结束时自动释放锁。

std::condition_variable：std::condition_variable 是 C++ 标准库中的一个类，用于实现线程间的条件变量和条件等待。可以通过 std::condition_variable 实现线程的等待和通知机制。

线程池（Thread Pool）：线程池是一种管理和复用线程的机制，可以预先创建一组线程，并维护一个任务队列，从队列中获取任务并分配给空闲的线程执行。

以下是一个简单的多线程编程的例程，使用了上述概念：

cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <vector>

std::mutex mtx;
std::condition_variable cv;
bool ready = false;

void worker(int id) {
    std::unique_lock<std::mutex> lock(mtx);
    while (!ready) {
        cv.wait(lock);
    }
    std::cout << "Worker " << id << " is working." << std::endl;
}

int main() {
    std::vector<std::thread> threads;
    const int numWorkers = 5;

    for (int i = 0; i < numWorkers; ++i) {
        threads.emplace_back(worker, i);
    }

    std::this_thread::sleep_for(std::chrono::seconds(2));

    {
        std::lock_guard<std::mutex> lock(mtx);
        ready = true;
        cv.notify_all();
    }

    for (auto& thread : threads) {
        thread.join();
    }

    return 0;
}
在上述例程中，创建了一个包含 5 个线程的线程池。每个线程会等待条件变量 ready 变为 true，然后开始执行工作。主线程在等待 2 秒后，将 ready 设置为 true，并通过条件变量的 notify_all 方法通知所有等待的线程开始工作。最后，主线程等待所有线程执行完毕，并调用 join 方法等待线程结束。

这个例程演示了互斥量、条件变量和线程池的基本用法，以及如何使用 std::thread、std::mutex、std::lock_guard 和 std::condition_variable 进行多线程编程。
