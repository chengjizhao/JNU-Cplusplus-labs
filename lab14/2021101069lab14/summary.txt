多线程编程是一种允许程序中不同部分并行执行的技术。在多核或多处理器的系统中，多线程编程可以显著提高程序的执行效率。C++标准库提供了一系列用于多线程编程的类和函数，如std::thread, std::mutex, std::lock_guard, std::condition_variable等。这些工具可以帮助我们有效地处理线程同步、互斥和通信等问题。

std::thread: std::thread是C++标准库中用于创建和管理线程的类。你可以使用它来启动新的线程，并传递一个函数或可调用对象（如lambda表达式）给新线程。
例程：
#include <thread>  
  
void my_function() {  
    // 线程执行的代码  
}  
  
int main() {  
    std::thread t(my_function); // 创建新线程，并开始执行my_function函数  
    t.join(); // 等待线程t完成  
    return 0;  
}



std::mutex: std::mutex是一个互斥量，用于保护共享数据，防止多个线程同时访问。当一个线程拥有互斥量时，其他尝试获取该互斥量的线程将被阻塞，直到拥有互斥量的线程释放它。
例程：
cpp
#include <mutex>  
#include <thread>  
#include <vector>  
  
std::mutex mtx; // 全局互斥量  
int shared_data = 0; // 共享数据  
  
void worker_thread() {  
    mtx.lock(); // 获取互斥量  
    ++shared_data; // 修改共享数据  
    mtx.unlock(); // 释放互斥量  
}  
  
int main() {  
    std::vector<std::thread> threads; // 存储工作线程的向量  
    for (int i = 0; i < 10; ++i) {  
        threads.push_back(std::thread(worker_thread)); // 创建新工作线程并启动它  
    }  
    for (auto& t : threads) { // 等待所有工作线程完成  
        t.join();  
    }  
    return 0;  
}



std::lock_guard: std::lock_guard是一个RAII（资源获取即初始化）包装器，用于自动管理互斥量的锁定和解锁。当std::lock_guard对象被创建时，它会自动锁定给定的互斥量，并在其生命周期结束时自动解锁互斥量。这可以防止因异常或早期返回而导致的未解锁互斥量的问题。
例程：
cpp
#include <mutex>  
#include <thread>  
#include <iostream>  
  
std::mutex mtx; // 全局互斥量  
int shared_data = 0; // 共享数据  
  
void worker_thread() {  
    std::lock_guard<std::mutex> lock(mtx); // 使用RAII自动管理互斥量的锁定和解锁  
    ++shared_data; // 修改共享数据  
    std::cout << "Worker thread updated data." << std::endl; // 输出消息表示数据已被更新  
}  
  
int main() {  
    std::thread t(worker_thread); // 创建新线程并启动它  
    t.join(); // 等待线程完成  
    return 0;  
}
std::condition_variable: std::condition_variable是一个条件变量，用于在特定条件下阻塞线程，直到其他线程发出通知。通常与std::mutex一起使用，以实现线程之间的同步。当条件变量被通知时，阻塞的线程将被唤醒并继续执行。
线程池: 线程池是一种多线程编程技术，其中一组线程在程序启动时被创建并保持活动状态，以处理来自任务队列的任务。这种技术可以减少线程创建和销毁的开销，提高程序的性能和响应能力。C++标准库没有提供线程池的直接支持，但你可以使用第三方库或自己实现线程池的概念