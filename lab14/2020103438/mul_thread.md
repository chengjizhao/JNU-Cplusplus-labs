# 进程
线程状态
- 排队
- 运行
- 等待

挂起，**是否占用实际的物理内存空间**

并发与并行：并发是多个任务在同一时间段内交替执行，而并行是多个任务在同一时间点同时执行。

**进程控制块**（*process control block，PCB*）描述进程

通过**链表**的方式进行组织，把具有**相同状态的进程链在一起，组成各种队列**

CPU上下文切换，**保存前一个进程的信息，加载下一个进程的信息**

# 线程
**线程是调度的基本单位，而进程则是资源拥有的基本单位**

**当进程只有一个线程时，可以认为进程就等于线程**

**单进程**

- 进程等待时间长
- 各个函数之间不是并发执行，花费时间长，影响资源的使用效率

**多进程**

- 进程之间如何通信，共享数据
- 维护进程的系统开销较大

**线程的实现**

- 用户线程
- 内核线程
- 轻量级线程，在内核中来支持用户线程

用户线程的整个线程管理和调度，操作系统是不直接参与的，而是由**用户级线程库函数**来完成线程的管理，包括线程的**创建、终止、同步和调度**等。

# 多线程编辑
`#include <thread>`多线程库

`#include <mutex>`

还是需要**创建对象**来使用

**锁**，用于控制对共享资源的访问，确保一次只有一个线程可以访问或修改该资源。通过锁，可以防止多个线程同时访问共享资源，从而避免数据不一致或竞态条件。

**互斥锁（Mutex）**

```C++
mutex mtx;//创建一个互斥量
lock_guard<mutex> lock(mtx);//创建lock


thread t1(print,1);//1为函数的参数
t1.join();
```

`unique_lock`

- 基本锁定和解锁
- 延迟锁定
- 通常与条件变量 (`std::condition_variable`) 一起使用，以便在某些条件满足时等待或唤醒线程。

```C++
std::unique_lock<std::mutex> lock(mtx);
cv.wait(lock, [] { return ready; });//使用 wait() 方法等待条件变量，直到其他线程调用 notify_one() 或 notify_all() 唤醒它

ready = true;
cv.notify_one();//通知
```


### 线程池

线程池是一种并发编程的机制，用于管理和复用线程。它包含一组预先创建的线程，这些线程在需要执行任务时被重复使用。

### 组件：

任务队列：存储待执行的任务。

线程池管理器：负责线程的创建、分配和回收。

工作线程：从任务队列中获取任务并执行。

### 优点：

降低资源消耗。

提高系统响应性。

管理并发度。
