多线程编程允许程序并行执行多个任务，最主要的实用场景是在需要大量计算或极高效率的程序中。C++11开始标准库中就提供对多线程的支持。

以下是多线程编程的一些基础知识并附有相关概念的例程：

1. std::thread: C++中的线程库，用于创建和操作线程。
```cpp
#include <iostream>
#include <thread>

void thread_func() {
    std::cout << "Hello from thread " << std::this_thread::get_id() << std::endl;
}

int main() {
    std::thread t(thread_func);
    t.join();  // 阻塞线程，直到完成

    return 0;
}
```

2. std::mutex(互斥量)：用于保护共享数据，防止多线程同时访问。
```cpp
#include <thread>
#include <mutex>

std::mutex mtx;
int counter = 0;

void increase_counter() {
    mtx.lock();
    ++counter;
    std::cout << counter << std::endl;
    mtx.unlock();
}

int main() {
    std::thread t1(increase_counter);
    std::thread t2(increase_counter);
    t1.join();
    t2.join();

    return 0;
}
```

3. std::lock_guard: 自动管理互斥量的生命周期。
```cpp
#include <thread>
#include <mutex>

std::mutex mtx;
int counter = 0;

void increase_counter() {
    std::lock_guard<std::mutex> lock(mtx);
    ++counter;
    std::cout << counter << std::endl;
}

int main() {
    std::thread t1(increase_counter);
    std::thread t2(increase_counter);
    t1.join();
    t2.join();

    return 0;
}
```

4. std::condition_variable: 用于线程间的同步，比如等待一个条件或者通知其他线程一个事件已经发生。
```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

std::mutex mtx;
std::condition_variable cv;

bool ready = false; 

void print_id() {
    std::unique_lock<std::mutex> lock(mtx);
    while (!ready) {
        cv.wait(lock);
    }
    std::cout << "thread " << std::this_thread::get_id() << '\n';
}

void go() {
    std::unique_lock<std::mutex> lock(mtx);
    ready = true; 
    cv.notify_all(); 
}

int main() {
    std::thread threads[10];
    for (int i = 0; i < 10; ++i)
        threads[i] = std::thread(print_id);

    std::cout << "10 threads ready to race...\n";
    go();                       

    for (auto& th : threads) th.join();

    return 0;
}
```

5. 线程池（Thread pool）：预先创建线程的工作队列，当有新的任务时直接利用这些预先创建的线程，避免频繁创建和销毁线程的开销。C++标准库并未设有内建的线程池，需要手动实现或寻找第三方库（如Boost安全函数库或使用std::async和std::future实现一个简易版本的线程池）。
