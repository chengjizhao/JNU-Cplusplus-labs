1、vector：
特点：vector是一个动态数组，支持随机访问。其内部元素在内存中是连续存储的，这使得访问任何元素（使用下标操作符）的时间复杂度都是O(1)。然而，向vector中添加或删除元素（尤其是在头部和尾部）可能需要移动其他元素，因此时间复杂度为O(n)。
使用场景：当你需要存储元素并且需要频繁访问元素（如通过下标）时使用vector。
2、list：
特点：list是一个双向链表，不支持随机访问。它的元素在内存中不是连续存储的，因此访问元素（尤其是通过迭代器）的时间复杂度是O(1)。添加或删除元素通常只需要调整指针，所以时间复杂度也是O(1)。
使用场景：当你需要存储元素并且需要频繁在列表的任意位置插入或删除元素时使用list。
3、deque：
特点：deque（双端队列）是一个支持在头尾进行快速插入和删除操作的容器。其内部实现通常为一个动态数组，所以它也支持随机访问。
使用场景：当你需要像vector一样支持随机访问，但又需要在头部和尾部进行频繁插入和删除操作时使用deque。
4、set/multiset：
特点：set和multiset是基于红黑树的关联容器，它们自动对元素进行排序。set中的元素是唯一的，而multiset允许重复的元素。查找、插入、删除操作的平均时间复杂度为O(log n)。
使用场景：当你需要存储排序的元素并且需要快速查找、插入或删除元素时，使用set或multiset。
5、map/multimap：
特点：map和multimap也是基于红黑树的关联容器，它们自动对键进行排序。map中的键是唯一的，而multimap允许重复的键。查找、插入、删除操作的平均时间复杂度为O(log n)。
使用场景：当你需要存储键-值对并且需要快速查找、插入或删除键-值对时，使用map或multimap。
6、unordered_set/unordered_multiset：
特点：unordered_set和unordered_multiset是基于哈希表的关联容器，它们不保证元素的顺序。unordered_set中的元素是唯一的，而unordered_multiset允许重复的元素。在理想情况下，查找、插入、删除操作的平均时间复杂度为O(1)。
使用场景：当你需要存储元素并且需要快速查找、插入或删除元素，而且不关心元素的顺序时，使用unordered_set或unordered_multiset。
7、unordered_map/unordered_multimap：
特点：unordered_map和unordered_multimap是基于哈希表的关联容器，它们不保证键的顺序。unordered_map中的键是唯一的，而unordered_multimap允许重复的键。在理想情况下，查找、插入、删除操作的平均时间复杂度为O(1)。
使用场景：当你需要存储键-值对并且需要快速查找、插入或删除键-值对，而且不关心键的顺序时，使用unordered_map或unordered_multimap。
8、array：
特点：array是一个固定大小的数组，不支持动态扩展。它的元素在内存中是连续存储的，因此访问任何元素的时间复杂度都是O(1)。然而，向array中添加或删除元素可能导致未定义的行为。
使用场景：当你需要存储固定数量的元素并且需要频繁访问这些元素时，使用array。
