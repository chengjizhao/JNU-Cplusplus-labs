array 即数组，其大小固定，所有的元素严格按照内存地址线性排列
vector的数据模型就是数组。内存和C完全兼容、高效随机访问、节省空间。支持随机访问，可以通过[]操作符和at()方法访问数据。可以不指定内存大小即可实现对像数组一样的操作，实际内部实现vector是预先分配了一块固定大小的内存，当超过该内存块时，vector会重新找一块更大的内存，并把当前的释放掉。可以快速的在尾部进行插入和删除，即通过push_back() 和pop_back()方法。越靠近头部位置的插入、删除效率低。扩容有消耗，存在一定的空间的浪费。只能在vector的尾部进行push和pop。添加数据占用内存超过vector预先分配的大小时，需要重新分配、拷贝与释放。使用场景：随机访问、存储元素的数目已知。
list的数据结构模型是链表。任何位置的插入删除的效率比较高。按需申请释放节点，空间利用率高，不需要预先分配内存空间，不存在扩容操作。不支持下标随机访问。cpu高速缓存命中率低。比verctor占用内存多，因为要存储其前驱和后继节点的信息。使用场景：需要任意位置随机插入删除。
deque是一种具有队列和栈的性质的数据结构。高效随机访问、内部插入删除元素效率方便。支持随机访问，可以通过[ ]操作符和at()方法访问数据。容器deque的迭代指针属于智能型指针。容器deque的迭代器属于随机存取迭代器。占用内存多，要通过迭代器来维护内存的整体连续，实际内部并不是连续的。在中间进行插入和删除时比较慢。需要更多在容器的首部尾部插入删除元素。
map 是一个关联型容器，其元素类型是由 key 和 value 组成的 std::pair。元素会按照键值排序、查找是对数时间复杂度、通过键值查元素、map提供了下标访问。map内部采用红黑数实现，需要额外空间保存节点，会占用多余的空间。	通过key值索引时，如果key值不存在，map会直接插入一个key-value键值对。	使用场景：当需要使用非int类型的数据作为下标时，可以使用map。
set 是一个关联型容器。元素插入速度慢，查找速度非常快，会自动排序功能。不能直接修改 set 容器中元素的值，修改set容器中的某个值，需要先删除该元素，再插入新元素。对数据有排序的要求。需要存储不重复的数据。
multimap 允许将具有相同 key 的不同元素插入容器。