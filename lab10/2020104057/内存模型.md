内存模型

编译器和CPU需要严格按照代码顺序进行生成和执行。对于多线程程序，由图1架构可知，每个线程的指令执行顺序由各自的CPU来控制，因而都有独立的执行顺序，但因为它们共享同一个内存，而内存修改的顺序是全局的（global memory order），我们可以以该全局顺序为参照，对所有线程进行同步。

内存模型是从来描述编程语言在支持多线程编程中对共享内存访问的顺序，本质是指在单线程情况下CPU指令在多大程度上发生指令重排

### 一般类对象的内存模型：

一般类对象的内存模型是最简单的，它们在内存中占用连续的空间，包含类的成员变量和非虚函数。没有虚函数表或虚指针。

### 继承类对象的内存模型：

继承类对象的内存模型是基于一般类对象的基础上进行扩展。派生类对象包含基类对象的成员变量和非虚函数，并按照继承关系依次排列。

### 带虚函数的类对象的内存模型：

带虚函数的类对象在一般类对象的基础上会增加一个指向虚函数表（vtable）的指针。虚函数表是一个指针数组，存储了虚函数的地址。每个类对象都有自己的虚函数表。

### 基类有虚函数的子类对象的内存模型：

如果派生类继承了基类的虚函数，并且没有添加自己的额外虚函数，那么派生类对象与带虚函数的类对象的内存模型相同。

### 基类有虚函数且子类有自己的更多虚函数的类对象的内存模型：

当派生类在继承基类的虚函数的同时，还添加了自己的额外虚函数时，每个类对象会拥有自己的虚函数表和虚指针。派生类的虚函数表将在基类的虚函数表之后排列。

### 多继承的类对象的内存模型：

多继承的类对象的内存模型是多个基类对象按照声明顺序依次排列而成。每个基类对象都包含各自的成员变量和非虚函数。

### 虚基类的类对象的内存模型：

虚基类的类对象会在派生类对象中保留一个虚基类指针（vbptr），用于指向虚基类的偏移位置。虚基类的成员变量只在最派生的类对象中存在一份。
