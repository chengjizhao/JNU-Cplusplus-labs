 C++允许在函数内部定义一个静态的內建类型变量，程序只在第一次进入时对其初始化，之后保持之前的值。
而如果没有为一个內建类型的静态变量提供一个初始值的话，编译器也会确保在程序开始时它被初始化为0，包括指针。
与上面的静态变量相比，不同的一点在于：零赋值只对內建类型有效，用户自定义类型必须用构造函数来初始化。
因此，如果在定义一个静态对象时没有指定构造函数参数，这个类就必须有默认的构造函数。
1、静态对象的销毁也是按与初始化时相反的顺序进行的。

2、全局静态对象比main函数先初始化，main函数退出后才进行析构。参考全局对象a，其构造函数在main函数开始之前被调用

3、在main函数中，即便局部静态对象aaa比aa晚初始化，但它并没有比aa先调析构函数。并且他也是在main函数退出之后才调用的析构函数。所以有以下结论：
1) 构造函数的调用顺序： 全局静态对象 >  进入main函数  > （局部静态对象  、临时对象）。括号中的对象的调用顺序要看代码中调用的顺序
2) 析构函数的调用顺序：main函数退出 ＞临时对象 > 局部静态对象 > 全局静态对象。同类的对象的析构按与构造函数的调用顺序相反的顺序调用。
这给了我们一种能力：再进入main()之前执行一段代码，并且可以在退出main()之后用析构函数执行代码。

