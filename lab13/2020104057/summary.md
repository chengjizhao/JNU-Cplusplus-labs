## 第14章

### 继承：

面向对象程序设计中最重要的一个概念是继承。继承允许我们依据另一个类来定义一个类，这使得创建和维护一个应用程序变得更容易。这样做，也达到了重用代码功能和提高执行效率的效果。

```c++
// 基类
class Animal {
    // eat() 函数
    // sleep() 函数
};

//派生类
class Dog : public Animal {
    // bark() 函数
};
```

当创建一个类时，您不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为**基类**，新建的类称为**派生类**。通过公有继承，派生类可以重用基类的代码，并建立is-a关系。私有继承和保护继承也能重用基类的代码，但建立的是has-a关系。

### 多重继承：

C++支持多重继承，从而大大增强了面向对象程序设计的能力。多重继承是一个类从多个基类派生而来的能力，派生类实际上获取了所有基类的特性。当一个类是两个或多个基类的派生类时，必须在派生类名和冒号之后，列出所有基类的类名，基类间用逗号隔开。 **派生类的构造函数必须激活所有基类的构造函数，并把相应的参数传递给它们**。派生类可以是另一个类的基类，这样，相当于形成了一个继承链。当派生类的构造函数被激活时，它的所有基类的构造函数也都会被激活。

允许在类设计中重用多个类的代码。私有MI或保护MI建立has-a关系，而公有MI建立is-a关系。但MI会引入一些问题，如名称二义性和继承多个基类对象的问题。

### 虚基类：

当派生类从多个基类派生，而这些基类又有共同基类，则在访问此共同基类中的成员时，将产生冗余，并有可能因冗余带来不一致性。主要用来解决多继承时可能发生的对同一基类继承多次而产生的二义性问题。

也用于解决多重继承中的菱形继承问题，避免继承多个基类对象。使用虚基类后，需要编写构造函数初始化列表和处理二义性问题的新规则。需要注意的是，继承和组合是两种不同的概念。继承是通过创建派生类来重用基类的代码并建立is-a关系，而组合是通过创建包含对象成员的类来重用代码并建立has-a关系。每种重用代码的方式都有其适用的场景和特点。

声明：

```cpp
class B1:virtual public B
```

## 《C++编程思想》第9章

虚基类背后的实现机制主要包括以下几个方面：

### 虚基类表：

编译器为每个包含虚基类的类生成一个虚基类表。虚基类表的作用是存储虚基类的偏移量，以便在派生类中访问虚基类的成员时能够正确定位。虚基类表相对于虚函数表要稍微难理解些，故单独提出来。虚函数表是在对象生成时插入一个虚函数指针，指向虚函数表，这个表中所列就是虚函数。

![img](https://images0.cnblogs.com/blog/560193/201309/06163455-d34a45a0399e4106a63ec32e751627f6.png)

虚基类表原理与虚函数表类似，不过虚基类表的内容有所不同。表的第一项表示派生类对象指针相对于虚基类表指针的偏移，从第二项开始表示各个基类地址相对于虚基类表指针的偏移。

### 虚基类构造与析构：

译器会根据不同的场景，生成不同类型的析构函数供程序进行调用。

在派生类对象的构造和析构过程中，需要负责初始化和清理虚基类子对象。为了避免重复构造和析构虚基类子对象，编译器使用虚基类表来跟踪已经构造和析构的虚基类子对象，并通过标记位来确保每个虚基类只进行一次构造和析构操作。

### 虚基类访问权限：

虚基类具有特殊的访问权限，它可以直接由派生类访问，而不需要通过基类的引用或指针。当派生类继承多个虚基类时，可以通过指定虚基类名字来区分不同的虚基类。

### 偏移量调整：

对于一个存储多个数据的int数组，我们可以通过设定个int* p的指针，只需将数组头指针赋给指针p，便可以通过指针p每次增加一个int数据的偏移量准确获取每个int类型数据。这里int数据的偏移量为4，若为其它类型数据则只需偏移该类型的内存大小即可。对于一个指针其遍历数据时，是通过数据与头地址的偏移量来获取的，而不是变量名。

由于派生类可能同时继承多个虚基类，因此需要对虚基类的指针进行偏移量调整，确保能够正确地访问虚基类的成员。编译器在派生类的对象中添加一个指向虚基类子对象的指针，并根据虚基类表中的偏移量调整该指针的值。
