程序员的自我修养第一章读书总结：
第一节：从最简单的hellow world引入然后思考hellow world程序执行的深层问题。
第二节：主要讲述了硬件体系，讲述了由于cpu核心频率的提升导致的其他硬件不符合条件因此升级换代。后面还讲述了多核处理器的原理：十个女人不可能在一个月生出一个孩子但是可以在十个月生出是个孩子。和多核处理器适用场景，例如大型数据库处理大量数据而且这些数据之间是彼此独立的这样就可以用多核处理器来加快进程。
第三节：系统软件分为两块：（1）平台性的，如OS内核、驱动程序、运行库和系统工具；（2）用于程序开发的，如编译器、汇编器、链接器等开发工具和开发库。系统软件分为不同的层次，每个层次之间都要通信，其协议一般称为接口，接口之下是服务提供者，接口之上是服务调用者。
第四节：讲述了OS是干什么的：（1）提供抽象的接口；（2）管理硬件资源。还讲述了cpu的发展历史和原因，从多道程序到分时系统到多任务系统到进程，发展的目的是为了提高cpu的利用率不要让菜谱空转甚至死循环。
第五节：提出了cpu不够了的解决思路：增加中间层，提供间接的地址访问方法，把程序给出的地址看作是虚拟地址，然后通过映射的方法，将虚拟地址转化成实际的物理地址。
第六节：提出了线程和多线程的概念并给出了多线程的优势：当某个线程进入休眠时多线程可以有效利用等待的时间其他线程可以正常工作。还在多线程的基础上提出了线程安全的概念：在多线程下由于可访问的全局变量和堆数据随时可能被其他线程改变因此数据的一致性变得很重要。

程序员的自我修养第六章读书总结：
一：虚拟地址空间。假设一个程序有4gb的虚拟地址空间但实际上这4gb不可能完全是给程序使用的。这4gb被分为两部分一部分被操作系统用掉另一部分也不能完全给程序使用因为还有一部分是留给其他用途的。
二：为了提高内存的利用率，用小内存装下更多东西就出现了动态装入。将程序最常用的部分留在内存中将其他部分放在磁盘这就是动态装入的原理。
三：创建一个进程在有虚拟存储的情况下只需要做三件事：1.创建一个独立的虚拟地址空间2.读取可执行头文件并建立虚拟空间和可执行文件之间的关系3.将cpu的指令寄存器设置成可执行文件的入口地址，启动运行
四：在映射进程虚拟空间时为了减少因段的数量增多而造成的内存浪费，可将相同权限的段当作一段合并进行映射。
五：这个小节讲述的是Linux系统是怎么装载整个ELF文件并执行的：首先在用户层面，bash进程会调用fork()系统调用创建一个新的进程，然后新的进程调用execve()系统调用执行指定的ELF文件，原先的bash进程继续返回等待刚才启动的新进程结束，然后继续等待用户输入命令。execve()系统调用被定义在unistd.h。Glibc对execvp()系统调用进行了包装，提供了execl()、execlp()、execle()、execv()和execvp()等五个不同形式的exec系列API，只是在调用的参数形式上有所区别，但最终都会调用到execve()这个系统中。在进入execve()系统调用后，Linux内核就开始进行真正的装在工作。
六：在这一小节了解到windows PE可执行文件的装载过程还了解到PE里的一个常见术语RVA，它是相对于PE装载基地址的偏移地址。在PE文件中基地址是可能发生变化的但是偏移地址可以保持一致。
