《程序员的自我修养》阅读总结：
第一章：
从最简单的程序：“hello world”出发提出有关于编程实现基础的问题，以及相关技术的发展历史
第一章前面几部分介绍了计算机的基本组成结构，为后面更为细致的介绍打下基础。
1.4介绍了操作系统的组成和各部分相关知识。
在运行程序时，我们希望CPU可以被充分利用起来，因此起初运用多道程序的方式提高CPU使用效率。
后来人们将程序通过一种“协作模式”运行，通过协调程序运行的轻重缓急，使程序不断让出CPU的方式，
不仅提高了CPU运行效率，还加快了程序运行速度。
硬件方面，繁琐的硬件细节全都交给了操作系统，具体地讲是操作系统中的硬件驱动程序来完成，这里着重讲了CPU的读写过程。
1.5介绍了解决内存的分配问题。
这里重要解决的问题就是程序之间的相互影响。主要思想就是“隔离”。
首先，通过增加中间层，使用间接的地址访问方法，用映射的方式达到地址空间的隔离。
进一步来说，可以通过分段，把一段与程序所需要的内存空间大小的虚拟空间映射到某个地址空间，使虚拟空间的每个字节和物理空间的每个字节一一映射。
但是分段不能解决内存使用效率的问题，因此需要分页。
分页是把地址空间人为地等分成固定大小的页，把进程的虚拟地址空间按页分割。
常用的数据和代码页装载到内存中，不常用的保存在磁盘里，以页为单位来存取和交换这些数据非常方便，硬件本身就支持这种以页为单位的操作方式。
1.6介绍了线程的问题。
首先是线程的基本知识：线程是程序执行流的最小单元。
组成：一个标准的线程由线程ID、当前指令指针（PC）、寄存器集合和堆栈组成。
状态：线程存在三种状态：等待，就绪，运行。
保障线程安全的措施：包括原子操作，使用锁，读写锁。
之后进行更进一步的介绍：多线程的并发执行情况。三种线程模型：一对一、多对一、多对多。分别阐述了这三种模式的特点和局限性。

第六章：
第6章前面部分介绍了程序运行的基本思路框架。
首先明确了进程是动态的这一概念。程序是预先编译好的指令和数据的集合，运行在虚拟地址空间中。
程序在运行时所需要的存往往大于物理存所能提供的。程序的局部性原理即程序在运行时只有一部分需要放进存。这就需要装载。
动态装载的基本原理是程序的局部性原理， 即程序用到哪个模块就把哪个模块放进存。动态装载的两种典型的方法是覆盖装入和页映射。
6.2介绍了覆盖和装载是如何完成的。
程序员手工编写用于控制模块动态装载的管理代码，被称为覆盖管理器。即各模块轮流共用存一片区域，程序员手动控制哪个模块在某一时刻进入该区域。
模块之间往往存在依赖的关系，单一模块无法完成功能，这种依赖关系使各模块间形成了树状结构。
把磁盘中所有数据和指令以页为单位进行划分，装载用的也是页。
6.3从操作系统角度看可执行文件的装载
创建独立的虚拟地址空间。
读取可执行文件头，建立虚拟地址空间与可执行文件的映射关系；
将CPU的指令寄存器设置为程序执行入口，开始运行。
CPU执行到空页面产生页错误，将控制权交给操作系统处理该错误。
6.4进程虚存空间分布
操作系统关心的只是段的权限，即只读、只写、读写。
操作系统通过VMA对进程的地址空间进行管理，比如堆和栈。
堆主管空间动态分配，受操作系统版本、程序本身大小、动态/共享库数量、程序栈数量大小等因素影响。
6.5和6.6分别介绍了Linux内核装载ELF过程，以及Windows PE的装载。
总结第六章：
围绕程序如何被操作系统装载到内存中进行运行，介绍了覆盖装入和页映射的模式，分析了为什么要以页映射的方式将程序映射至进程地址空间，这样做的好处是什么，
并从操作系统的角度观察进程如何被建立，当程序开始运行时发生页错误该如何处理等。
