代码1
#include <stdio.h>
#include<stdlib.h>
int main()
{
  int*p=(int*)0xc0000fff;
  *p=0;
}
访问了不属于进程地址空间的内存。
应改变访问地址



代码2
#include <stdio.h>
#include<stdlib.h>
int main()
{
  char *c ="hello world";
  c[1]=‘H’;
}
错误的访问类型引起
该内存区域是只读。
应把char改为int




练习加减乘除
#include <stdio.h>
int Add(int x, int y)
{
    return x+y;
}
int Sud(int x,int y)
{
    return x-y;
}
int Xud(int x, int y)
{
    return x*y;
}
int Cud(int x, int y)
{
    return x/y;
}//以上是为了定义选择功能后执行的功能区域段。是选择功能后才执行的区域
int main()
{
    printf("*******************\n");
    printf("*****1.加法\n");
    printf("*****2.减法\n");
    printf("*****3.乘法\n");
    printf("*****4.除法\n");
    printf("********************\n");
    int x=0,y=0,n,ret;
    int (*parr[5])(int,int)={0,Add,Sud,Xud,Cud};//定义一个函数指针数组，0是为了让选择功能时与输入的对应
    {
        printf("请选择:\n");
        scanf("%d", &n);
        if (n ==0)
        printf("关闭计算器\n");
        else if (n>=1 && n<=4) //对功能段进行循环对比，如果输入结果与定义结果一致，则使用该功能段
        {
            printf("请输入两个数字\n");
            scanf("%d %d", &x, &y);//得到两个数字进行运算
            ret = parr[n](x,y); //循环节点
            printf("结果为:%d\n",ret);
            while(n);
            return 0;
        }
    }
}





《程序员的自我修养》第一章第六章读后感
第一章
不要让CPU打盹，个人理解为 把任务进行细分分成安排给CPU多线程处理。在任务量巨大的时候应尽量让CPU满负荷处理同时处理多个任务。且通过优先级调度为用户急需处理的任务进行分配安排。
内存不够的处理方法可通过调度分配多线程处理，在计算量日益增加的当下内容不够是必然的。且通过虚拟内存与虚拟地址多线程使用物理内存。
线程安全因为在同一时刻处理的所有线程是同享一个地址。为防止数据覆盖需通过加锁的操作保证线程安全。

第六章
进程虚拟地址空间：每个进程都会有独有的虚拟地址。因为把计算机里的物理内存通过虚拟内存的虚拟地址通过分配处理各个进程。32位的操作系统因为预留和操作系统的自身需求。仅能提供2G的物理内存使用。
通过看一个指针的大小可以看出操作系统是多少位的。
装载方式。因为程序的局部性原理可以通过覆盖装置、页映射覆盖。可通过映射的方式优化使用物理内存。
进程的建立：通过虚拟地址申请建设页目录。并通过页映射的方式讲虚拟地址放入页目录。CPU指令寄存器将其设置成可执行文件入口。
