# 抽象、分层、派生

注：本文为阅读《程序员的自我修养》第一章后所作总结。

推荐前往博客阅读：[https://louisz.top/2023/09/15822.html](https://louisz.top/2023/09/15822.html)

书本对第一章的定位是“基础复习”，但是对我而言并不算复习，而更像是基础知识科普，或者说，是为了能读懂这本书而学习的一些新内容。
这本书的作者也的确高明，虽然我过去基本上没有学习过这些内容，但也能够基本明白第一章所介绍的东西。

总的来说，我认为第一章的内容总结起来就是三点：抽象、分层、派生

## 抽象
操作系统通过驱动程序的方式，把实际的硬件操作抽象为接口，并提供给各类软件，程序员无需关心发送什么指令、 指令发往哪个端口等细节，可以把更多的时间
花在具体功能的实现上。

内存方面则通过隔离、段映射和分页的方式，把实际的物理内存抽象为独立的内存空间，使内存的利用效率大大提高。 

在CPU资源的分配方面，时间片机制让多进程同时运行得以实现，对每个进程而言，它们都独占一个抽象的CPU。每个进程中又可以分为多个线程，
每个线程享有独占的寄存器和栈空间，这些独占空间同样是抽象的结果。

硬件设备本身也有抽象，如书中提到的硬盘LBA扇区编号方式，把盘面、磁道、扇区疏密等细节抽象为带编号的逻辑扇区，供操作系统读取，为开发人员提供了极大的便利。

另外，像Java、Python、.Net、Nodejs等语言，也是建立在各自的抽象框架上的。如Java有JVM虚拟机，Python是CPython解释器。

## 分层
我认为，分层实质上是抽象的结果。下面这张图来自于书中（侵删）：
![计算机软件体系结构](https://cdn.ncmc.me/2023/09/00/00.jpg)

操作系统把硬件抽象为供软件使用的各种接口，于是操作系统就是硬件的上一层。各种运行库给软件提供和操作系统交互的抽象接口，因此运行库成为
了操作系统的上一层。所有的上层软件就通过这种分层结构井然有序地进行工作。

## 派生
派生是指在已有的基础上，加入新的特性，形成新的东西。

第一章中一个很明显的派生的例子是线程的锁机制。总共有四种锁：信号量、互斥量、临界区、读写锁。我认为，前三种锁构成典型的派生关系。如图

![锁的派生关系](https://cdn.ncmc.me/2023/09/00/01.jpg)

从上往下，每种锁在加入了新的特性后派生为新的锁。这和面向对象编程中类的派生十分类似。很多计算机软硬件的不断发展就是一个不断派生的过程。

最早的计算机中，处理器和内存以及各种I/O控制器连接在同一条总线上。随着硬件发展，出现了北桥、南桥等中转设备，再后来又出现了PCIe等
总线结构以满足新硬件的需求。基于冯诺依曼结构，人们不断加入新的硬件，形成了现在的计算机。这种派生的思想在开发中也十分重要。


