第一章

第一节提出来一些问题，作者通过这些问题介绍了本书的适用人群，以及粗略介绍本书涉及的内容。

第二节主要介绍了计算机硬件的结构
关键知识点有：
三个关键部件——CPU、内存、IO控制芯片
其实计算机硬件框架发展越来越复杂，主要是CPU核心频率的提升，内存、IO设备跟不上了，IO控制芯片就是来协调IO设备和总线速度的（CPU直接连接在总线上）。
后来设计了南桥和北桥芯片，北桥负责处理高速设备，南桥负责处理低速设备。
为了应对因CPU制造工艺限制的频率提高问题，提出了增加CPU数量的方案。一开始是单纯的增加数量，即SMP（对称多处理器），后来是CPU共享缓存部件（多核处理器）。

第三节介绍计算机的软件架构
主要思想：分层设计，层与层之间通过“接口”通讯，下层定义接口，上层调用接口。
文中介绍的软件体系架构为：最底层为硬件，硬件的上一层是操作系统内核主要包括操作系统和硬件驱动程序，再上一层是运行库（不太懂这是什么，是C语言库这种？），运行库为应用层和开发工具层提供接口。也可以大致分为：硬件层，中间层、应用层。

第四节介绍操作系统及作用
功能：
1.抽象化底层信息，为上层提供接口
2.管理硬件资源
操作系统的发展：由一开始的多道程序（设计监控程序，不让CPU空闲下来），到分时系统，再到多任务系统。最终目的都是合理利用硬件资源
设备驱动：驱动程序和操作系统一样运行在内核层，现在主要是由设备厂商提供。目的是为了屏蔽硬件细节。

第五节介绍内存管理
这里有几个概念：
一是映射，增加中间层，即虚拟空间，这是虚拟存储，需要硬件支持，即MMU，内存管理单元，一般集成在CPU上。
二是分段，分段就是每个进程占一段，然后虚拟地址和物理地址一一对应？这里我不是很清晰，感觉文中介绍的分段和映射是一回事。
三是分页，把地址空间分为固定大小的页，一般为4KB，具体多大由操作系统设定，但是是固定大小的。

第六节介绍多核、多线程。
线程是程序执行流的最小单元。由线程ID、当前指令指针PC、寄存器集合和堆栈组成。
介绍了线程概念后，再介绍线程的访问权限，以及线程调度方法：优先级和轮转法
线程安全，主要是多线程并发运行后，由于他们共享数据，特别涉及到写操作时，很容易导致一些意想不到结果。从而引出了锁。
文中介绍了几种锁：二元信号量、互斥量、临界区、读写锁，以及介绍了条件变量这种同步方法。
线程模型：用户线程和内核线程的对应关系：一对一、多对一、多对多。

第六章

第一节介绍进程虚拟地址，其实也差不多是那个思想，把虚拟地址和物理地址一一映射
然后介绍了Linux和Windows下的内存分配——以32位机器（4GB）为例。Linux操作系统为3GB+1GB，Windows操作系统为2GB+2GB。不过作者提到Windows操作系统可以更改用户可操作内存空间大小，改为3GB。
地址拓展：PAE和AWE。PAE是增加地址线，AWE是窗口映射方法，大概意思是有一块额外的地址空间，程序若需要可以申请。

第二节提出了程序执行前必须把指令和数据转载进内存。
最简单的方法是静态装载，就是全部装入，但是这样耗费内存很大，因为有一些数据不是常用的，却一直在占用内存。
引出动态装载：覆盖装入和页映射
覆盖装入：大致思路就是，把没有调用依赖关系的模块分开放入内存，运行到那个模块就把另一个模块数据指令去掉，腾出位置载入当前运行的模块数据指令。为了从复杂的模块关系中看出他们的依赖情况，可以把他们关系组织成树状结构。由于要频繁读取数据，这是典型的用时间换空间的方案。
页映射：以页为单位进行程序装载，通过“装载管理器”控制，大概思想就是用到哪些数据或指令，发现他们不在，就以页为单位装载到内存，内存不够就要放弃一些已经装载了的页。至于放弃哪些，就要看算法如何设计了。


第三节，从操作系统的角度看可执行文件的装载
首先程序运行需要先创建进程，如何装载、执行。
操作系统需要做三件事：
创建虚拟空间：建立虚拟空间与物理空间的映射关系。
建立虚拟空间与可执行文件的映射关系
将CPU指令寄存器设置为可执行文件入口，启动运行：跳转
页错误：页错误是指执行程序的时候，发现可执行文件对应的虚拟空间是空白页。我感觉文中介绍的页错误不是一个报错，是说在程序执行的时候，还没有进行第一件事：创建虚拟空间，而是有页错误之后，才创建虚拟空间，建立虚拟空间与物理空间的映射。或者说遇到页错误的时候，操作系统自己就解决了，用户看到的程序还是能够正常。

第四节介绍进程的虚拟空间分布
主要是讲程序装载至进程空间之后会有很多数量的段，因为内存是分页形式存储的，而段却不一定是页的整数倍，所以很容易产生页码内部碎片，浪费地址空间。于是从减少内存浪费的角度出发，提出来把相同权限的段合并在一个段上。后面好像也是按照这就思路展开，但是细节文中是以Linux下实例展开的，我没怎么看懂

第五节介绍Linux内核装载ELF文件并执行的过程，调用一些API举了个简单的实例
大致步骤是：先创建进程（fork()接口），然后execlp调用了sys_execve（），检查参数后再调用do_execve()，查找执行文件，读取前128个字节来判断执行文件格式，然后调用search_binary_handle()，根据格式调用相应的装置处理过程，如ELF文件调用的是load_elf_linary（），从这里开始就算是正式装载了。执行完这个之后得到可执行程序的入口地址，层层返回到用户态，eip寄存器就开始跳转掉那个入口地址执行。

第六节介绍Windows下PE文件的装载。
介绍了相对虚拟地址RVA和基地址的概念，通过这个方法是PE文件各个RVA都一样。只不过基地址会改变，然后文字提到了rebasing机制，不过这一章还没有详细介绍。












