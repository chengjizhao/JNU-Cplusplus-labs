1.如何让计算机运行得更有效率，在更短的时间内处理更多的任务：
   CPU:  多道程序（无法协调程序的优先级，“程序之间不分轻重缓急”）---->分时系统（完整的操作系统的雏形，每个程序运行一段时间以后都主动让出CPU给其他程序，但当某个程序耗时太长或陷入死循环时，都会导致系统死机）----->多任务系统（程序以进程的方式运行，且拥有各自独立的地址空间，CPU根据进程优先级进行分配）；
   I/O设备：硬件驱动程序；
   存储器（包括内存和磁条）：提高内存的利用率，将计算机上有限的物理内存分配给多个程序使用。在内存分配中应注意常会出现三种问题：地址空间不隔离，内存使用效率低和程序运行的地址不确定。
       解决地址空间不隔离和程序运行的地址不确定：对程序数据分段，将虚拟地址映射为计算机内存中的实际物理地址，每个进程都有自己独立的虚拟空间，且只能访问自己的地址空间，可保证程序访问的物理内存区域跟另一个程序互不重叠。
       解决内存使用用效率低：分页。把进程的虚拟地址空间按页分割，把常用的数据和代码页装到内存中，把不常用的代码和数据保存在磁盘里，需要时再从磁盘中取出。虚拟页和物理页之间进行页映射。
2.线程调度
    线程调度中，线程拥有三种状态：运行，就绪（处于运行中的线程的时间片用尽），等待（运行中的线程的时间片未用尽，等待事件发生，无法继续执行该线程）。
    线程调度方式主要有两种: 轮转法和优先级调度。
       轮转法---各个线程轮流执行一小段时间；当线程离开运行状态时，调度系统会选择其中一个已就绪的线程继续执行，在处于等待状态中的线程所等待的事件发生之后，线程进入就绪状态。
       优先级调度---具有高优先级的线程会更早执行，低优先级线程，需等待所有优先级高于它的线程执行完后才能够执行。存在“饿死”现象，即低优先级线程始终无法执行。为避免该现象，调度系统常常会逐步提升那些等待了过长时间的得不到执行的线程的优先级。
    多个线程同时访问一个共享数据，可能会导致程序运行结果出错。为避免此种情况，需要将各个线程对同一个数据的访问同步，即在一个线程访问数据未结束时，其他线程不得对同一个数据进行访问（对数据的访问被原子化）。常用的方法是使用锁，每一个线程在访问数据或资源之前首先试图获取锁，并在访问结束之后释放锁。在锁已经被占用的时候试图获取锁时，线程会等待，直到锁重新可用。
3.可以使用volatile关键字避免线程过度优化：1），阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回；2），阻止编译器调整volatile变量的指令顺序，但无法阻止CPU动态调度换序。
4.Segmentation fault：进程访问了未经允许的地址。进程只能使用操作系统分配给进程的地址，如果访问未经允许的空间，那么操作系统会捕捉到这些访问，将进程的这种访问当作非法操作，强制结束进程。
5.程序执行的指令和数据装载至内存共有两种方式：静态装入（指令和数据全部装入内存中）和动态装入（将程序需要的模块放入内存中，并将一些不太常用的数据存放在磁盘中）。覆盖装入（现如今几乎已被淘汰）和页映射（虚拟存储机制的一部分）是两种常用的动态装载方法。
6.创建进程，装载相应的可执行文件并执行：1）.创建虚拟地址空间（页映射函数）；2）.读取可执行文件头，建立虚拟空间与可执行文件的映射关系（页错误，分配物理地址）；3）.将CPU指令寄存器设置成可执行文件入口，启动运行。
7.Segement：ELF中，属性相似，又连在一起的段，如代码段（可读可执行的段落），数据段（可读可写的段）。系统是按照Segment而不是Section来映射可执行文件的。
