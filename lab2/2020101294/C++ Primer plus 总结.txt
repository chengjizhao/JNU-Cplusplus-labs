C++ Primer plus
第一章
1、C++简介
C++融合了3种不同的编程方式：
1.C语言代表的过程性语言
2.C++在C语言基础上添加的类代表的面向对象语言
3.C++模板支持的泛型编程

C++继承C语言高效、简洁、快速和可移植性的传统。

2、C++简史
2.1 C语言编程：过程性语言
Bell实验室的Dennis Ritchie为了实现UNIX的通用性、可移植性等，在旧语言的基础上开发了C语言。
汇编语言依赖于计算机的内部机器语言，直接对硬件进行操作。
数据：程序使用和处理的信息。
算法：程序使用的方法。
C语言是过程性语言 ，强调编程的算法方面，是一种结构化的编程方式。
C语言的新原则：自顶向下设计，理念是将大型程序拆分为小型的便于管理的任务。

2.2 面向对象编程
过程性语言（C语言）强调算法，OOP（C++、Java等）强调数据 。
OOP不像过程性编程，其理念是设计与问题的本质特性相对应的数据格式。区别如下：
1.过程性语言——让问题来满足语言。
2.OOP编程——让语言来满足问题。

在C++中，类是一种规范，描述了新型数据格式，特定数据结构对象则根据类规范构造。
类规定了哪些数据可使用来表示对象，以及可以对这些数据执行哪些操作。

OOP程序设计方法：先设计类（可以明确表示程序要处理的东西），然后设计使用类的对象的程序。

从低级组织（如类）到高级组织（如程序）的处理过程叫做自下而上编程思想。

类定义 = 数据 + 方法

OOP可以创建可重用的代码，减少大量的工作，信息隐藏可以保护数据，使其免遭不适当的访问。

不同的环境（Windows和Macintosh）下提供编程的类库，可以方便地重用和修改现有的、经过仔细测试的代码。

2.3 C++和泛型编程
泛型编程（generic programming）是C++支持的另一种编程模式，与OOP目标协同。
泛型——指创建独立于类型的代码。

OOP与泛型编程的区别：
1.OOP强调编程的方面，数据是管理大型项目的工具
泛型编程强调独立于特定数据类型，提供执行常见任务（如对数据排序或合并链表）的工具。
2.泛型编程需要对语言进行扩展，以便可以只编写一个泛型（即不是特定类型的）函数，并将其用于各种实际类型。

3、可移植性和标准
C++是C语言的超集，任何有效的C程序都是有效的C++程序。

3.1 可移植性的两个障碍
1.硬件：分块放置模块，通过重写模块，最大限度降低可移植性问题。
2.语言上的差异性：国际组织定义了C语言标准、定义了C++99、C++11、C++14等标准。
3.2 C++的二重性
1.OOP提供了高级抽象
2.C提供了低级硬件访问

C++既可以通过OOP进行抽象，也可完成类似C一样的对硬件访问的操作。

4、程序创建的技巧
4.1 编程步骤
1.定义程序目标
2.设计程序
3.编写代码
4.编译(源代码)
5.运行程序Windows、Unix、Linux)
6.测试和调试程序
7.维护和修改程序

4.2 常见的编译器
1.Linux/UNIX ： GNU gcc/g++
2.视窗 ：软件IDE
3.Mac OS ： Xcode自带g++和clang

第二章
1. 进入C++

对于一个C++ 程序主要包含以下元素：
1.注释：由前缀//或者是/* */标识
2.预处理器编译指令#include
3.函数头：int main() 
4.编译指令：using namespace
5.函数体：用括起来{ } 
6.使用C++ 的工具显示消息的语句cout
7.结束函数的语句main()return

1.1、函数头main()
main() 被启动代码调用，而启动代码是编译器添加到程序中。
空括号的main() 不接受任何参数。

main()函数描述了函数的行为。同时也构成了两部分的 函数定义（function definition） ：第一行int main()函数叫做 函数头（function heading），花括号({和})中包括的部分叫函数体。

函数体：指出函数应做什么的计算机指令。

在C++中，每条完整的指令叫做语句。所有的语句都是以分号结束。



main()中最后一条语句叫做返回语句（return statement），结束main()函数。 

注意：C++程序通常是以函数开始执行，如果没有main() ，程序不完整，编译器会指出未定义main()函数。
大小写都必须准确
不需要main()函数的特殊情况：
1.Windows中的动态链接（DLL）模块。
2.单片机或机器人芯片

1.2、C++注释
C++中的注释以 双斜杠（//） 打头。以行尾作为结束。
注释的作用：为程序提供解释说明，使得程序通俗易懂。
通常标识程序的一部分或者是标识代码的某个方面。
注意点：编译器不会运行，会直接忽略注释。

C++也可以识别C语言的注释

C语言风格的注释

多行注释：符号/*和*/之间，以*/作为注释的结束。
单行注释：以双斜杠（//）开始，行尾作为结束。

1.3、预处理器和头文件
如果程序要使用C++输入或输出工具时，必须使用两行代码：

#include <iostream>
using namespace std;

使用了#include作为了预编译指令，也就是所谓的预处理器指令。

预处理器的操作：在源代码被编译之前，替换或添加文本。

例如：

#include <iostream>

像iostream这样的文件叫做包含文件（include file） ———— 也被包含在其他的文件中，所以也叫做头文件（header file）。

1.4、名称空间（namespace）
如果程序中使用的是iostream，那么就需要使用名称空间编译指令来使得对程序可用。
using namespace std;
也叫做 using编译指令。

1.5、使用cout进行C++的输出
    cout<<"Come up an C++"<<endl;
    cout<<"You won't regret it"<<endl;
双引号括起来的部分就是要打印的消息。

在C++中，使用双引号括起来的一系列字符叫做字符串，由于若干个字符组合而成。

<< 指出信息流动的路径，cout是一个预定义的对象。



初识运算符重载
<< 既可以是插入运算符，也可以是左移运算符。

典型的运算符重载的情况，通过重载，同一个运算符代表不同的含义。具体含义编译器会通过上下文来确定。

常见的运算符重载例子
1.& ----> 既表示地址运算符，又表示按位AND运算符。
2.* ----> 既表示乘法，也表示对指针解除引用。

控制符endl
cout<<endl;
endl 是C++中的一个特殊符号，作用：重起一行。

在输出流中插入endl使得屏幕光标移到下一行开头。

endl在头文件iostream中定义，且位于名称空间std中。

换行符
C++也也提供了早期C语言表示换行的方法：C语言符号\n。

\n 被视为一个字符，名为换行符，也就是C++中的endl的重起一行。

显示字符串时，在字符串中包含换行符，而不是在末尾添加endl，可减少输入量。

/*两个语法都是一样的，都是：重起一行*/
cout<<"\n";
cout<<endl;

1.6、C++源代码风格
C++中源代码的风格遵循以下规则：
1.每条语句各占一行。
2.每个函数都有一个开始花括号和一个结束花括号，两个花括号各占一行。
3.函数中的语句都相对于花括号进行缩进。
4.与函数名称相关的圆括号周围没有空白。

2. C++语句
程序代码例子：

#include<iostream>
using namespace std;

int main()
{
    int carrots; // 声明一个整型变量

    carrots = 25; // 给变量赋值
    cout<<"我有 "<<carrots<<" 个carrots."<<endl;

    carrots = carrots - 1; // 对变量进行修改
    cout<<"快看！快看！现在，我有 "<<carrots<<" 个carrots!"<<endl;

    return 0;   
}

2.1 声明语句和变量
在C++中，首次使用变量时，必须声明 。可以避免因拼写错误而难以发现错误。

声明通常指出要存储的数据类型和程序对存储在内存里的数据使用的名称。

程序中定义声明的声明语句叫作语句，简称定义。定义会使得编译器为变量分配内存。

声明不一定是定义。

2.2 赋值语句
赋值语句将值赋给存储单元。

符号=叫作赋值运算符。Tips：C++中允许连续使用赋值运算符。

赋值是从右向左进行。

3. 其他C++语句
3.1 cin 和cout
cin 使用>>运算符从流中抽取输入字符。

可以将通过键盘输入的一列字符（即输入）转换为接收信息的变量能够接受的形式。

cout 的对象属性包含一个插入运算符<<，将右侧的信息插入到输出流中。

<< 运算符可以进行多条输出语句的拼接。

3.2 类的简介
类是C++面向对象编程（OOP）的核心概念之一。

类是用户定义的一种数据类型。

要定义类，需要描述它能够表示什么信息和可对数据执行什么操作。

类定义描述的是数据格式及其用法，而对象则是根据数据格式规范创建的实体。

两个类 和 cin类cout类
cin类：istream类对象
cout类：ostream类对象描述了ostream类定义表示的ostream对象以及对它数据执行的操作。
两个类没有被内置到编译器中。 注意点：类描述了一种数据类型的全部属性（包括使用它执行的操作），对象则是根据描述创建的实体。

C++中信息发送的方式
1.使用类方法（函数调用等）
2.重新定义运算符

4. 函数
两种C++函数
1.有返回值
2.无返回值

4.1 有返回值的函数
有返回值的函数将生成一个值，而值将赋值给变量或其他的表达式中使用。
被调用函数：被调用的函数
调用函数：包含调用的函数
返回值：发送回的值
参数 是发送给函数的信息， 返回值 是从函数中发送回去的值。
对于C++编译器而言，函数的参数类型必须和返回值类型一致 。

C++程序应当为程序中使用的每个函数提供原型。

函数原型结尾必须以分号(;)结束。如果省略分号，编译器则认为是函数头，要求提供定义该函数的函数体。

不要混淆函数原型和函数定义
函数原型只描述函数接口。
函数定义包含函数的代码。
首次使用函数之前提供原型，一般把原型放在main()函数定义前面。

4.2 函数变体
在原型中使用关键字void来指定返回类型，指出函数没有返回值。
void bucks(double);
关键字void不接受任何参数。如果省略void，让括号为空，则C++解释为一个不接受任何参数的隐式声明。
int rand(void);
4.3 用户定义的函数
对于库函数，在使用之前必须提供其原型，通常把原型放在main()定义之前。

函数格式 函数格式为：。 一个函数头 + 花括号的函数体
type functionname(arguementlist)
{
    statements
}

C++ 不允许将函数定义嵌套在另一个函数中，每个函数定义独立。

函数头——例如函数头main()。
关键字是专用词，不能用作他用。

return不能用作变量名，double不能用作函数名。

4.4 用户定义的有返回值的函数
有返回值的函数，使用关键字return来提供返回值，并结束函数。

函数的特性
1.有函数头和函数体
2.接受一个参数
3.返回一个值
4.需要一个原型

4.5 在多函数程序中使用using编译指令
让程序访问名称空间std的4种方法
1.将using namespace std;放在函数定义之前，让文件种所有的函数都能够使用名称空间std中所有的元素。
2.将using namespace std;放在特定的函数定义之前，让该函数能够使用名称空间std中的所有元素。
3.在特定的函数中使用类似；编译命令，而不是using std::coutusing namespace std；让该函数能使用指定的元素，如cout。
4.完全不使用编译指令using，而在需要使用名称空间std中的元素时，使用前缀std::。

第三章
1. 简单变量
程序必须记录3个基本属性
1.信息将存储在哪里
2.要存储什么值
3.存储何种类型的信息

1.1 变量名
C++变量命名规则
1.在名称中只能使用字母字符、数字和下划线（_）。
2.名称的第一个字符不能是数字。
3.区分大写字符与小写字符。
4.不能将C++关键字用作名称。
5.以两个下划线或下划线和大写字母打头的名称被保留给实现（编译器及其使用的资源）使用。以一个下划线开头的名称被保留给实现，用作全局标识符。
6.C++对于名称的长度没有限制，名称中所有的字符都有意义，但有些平台有长度限制。
变量名建议使用 的格式。例如：myEyeTooth 或 my_eyes。驼峰式

1.2 整型
整数：没有小数部分的数字。如：77、-120等。

C++中，不同的整型使用不同的内存量，使用的内存越大，可表示的数值范围越大。

整型分为：
1.正值
2.负值

1.3 整型短、整、长、长
计算机内存的基本单元：位（bit） 。
字节（byte） 通常是8位的内存单元。字节指的是描述计算机计算机内存量的度量单位。
单位换算：
1 KB = 1024 byte
1 MB = 1024 KB
在C++中也确保了类型的最小长度
1.短 至少 16位
2.int 至少和 short一样长
3.long至少32位，且至少与int一样长
4.long long 至少 64位，且至少与long一样长。

要知道系统中整数的最大长度，可以使用C++工具来检查类型的长度。
首先使用sizeof运算符返回类型或变量的长度，单位为字节。
climits中包含符号常量（预处理方式）来表示类型的限制。

#include<iostream>
#include<climits> // 定义了符号常量来表示类型的限制
using namespace std;

int main()
{
    // 变量的初始化
    int n_int = INT_MAX;
    short n_short = SHRT_MAX;
    long n_long = LONG_MAX;
    long long n_llong = LONG_MAX;
    /**使用sizeof()运算符, 不是函数
     * 
     * 可对类型名（如int）或者是变量名（如n_short）使用，对变量名使用时，括号可有可无。
     */
    cout<<"int 是 "<<sizeof(int)<<" bytes "<<endl;
    cout<<"short 是 "<<sizeof n_short<<" bytes "<<endl;
    cout<<"long 是 "<<sizeof n_long<<" bytes "<<endl;
    cout<<"long long 是 "<<sizeof n_llong<<" bytes "<<endl;
    
    // 最大值
    cout<<"MAXIMUM Values:"<<endl;
    cout<<"int : "<<n_int<<endl;
    cout<<"short : "<<n_short<<endl;
    cout<<"long : "<<n_long<<endl;
    cout<<"long long : "<<n_llong<<endl;

    // 最小值
    cout<<"MINIMUM int value = "<<INT_MIN<<endl;
    cout<<"Bits per byte = "<<CHAR_BIT<<endl;

    return 0;
}

1.4 变量初始化问题
初始化将赋值和声明合并在一起。也可以使用字面值常量来初始化。也可以直接使用表达式来初始化变量。
int variable00 = value;
int variable01 = value1 + value2;
int variable02(4);
如果不对函数内部定义的变量进行初始化，该变量的值不确定的。

将大括号初始化用于单值变量。

int emus{7};
int rheas{12};
int var = {12};

大括号初始化器可用于任何类型（可以使用等号，也可以不使用），属于通用的初始化语法。
1.在大括号内也不包含任何东西。此时变量初始化为零。
2.变量的初始化的问题，有助于防范类型转换错误。

1.5 无符号类型
优点：可以增大变量能够存储的最大值。
创建无符号类型的变量时，只需要使用unsigned来进行声明即可。
short变量加unsigned和没有unsigned，两者显示结果都是不一样的。

unsigned int un_int = 100;
unsigned short u_sint = SHRT_MAX;

1.6 整型字面值
整型字面值（常量）：显式书写的常量。如777或者是222。

C / C++中的三种计数方法：
1.十进制（第一位为1～9，基数为10）----> dec
2.八进制（第一位为0，基数为8） ----> oct
3.十六进制（前两位以0x或0X开头，基数为16，0～9和a～f（A～F）的组合）----> hex

默认情况下，cout以十进制形式显示整数。

1.7 char类型：字符和小整数
char类型：专门存储字符（如字母和数字），也是另外一种整型。

一般不超过128个字符，可以表示计算机系统中的所有基本符号 -----> 所有的字母、数字和标点符号等。

ASCII字符集中的字符用数值编码（ASCII码）进行表示。如字符A的编码为65。

#include <iostream>
int main(void)
{
   char ch = 'M';
   std::cout <<"The ASCII code for "<< ch <<" is "<<int(ch)<<std::endl;
   std::cout.put(ch); /* . 句点被称为成员运算符*/
   std::cout << std::endl;
   return 0;
}

成员函数cout.put() ———— C++ OOP概念中的成员函数，成员函数归类所有，描述了操作数据的方法。
在可使用数字转义序列或符号转义序列（如\0x8和\b）时，应使用符号序列。
数字表示与特定的编码方式（如ASCII码）相关，而符号表示适用于任何编码方式，其可读性也更强。
将转义序列作为字符常量时，使用单引号，如果放在字符串时，则使用双引号

cout << endl; /*使用endl重起一行*/
cout <<'\n'; /*字符串常量*/
cout <<"\n"; /*字符串*/

1.8 布尔类型
来源于数学表示法。

C++将非零值表示为true，将零表示为false。

bool is_ready = true;

2. 恒常符
符号名称指出了常量表示的内容。
const关键字来修改变量声明和初始化。常量被初始化后，其值就被固定，编译器将不允许再修改该常量的值。
将名称的首字母大写，以便提醒Months是个常量，可便于阅读性增强。如果是变量名全大写，则使用#define 。
创建常量的通用格式为：

const type name = value;

例如：

const int Months = 12; // 一年有12个月

如果在声明const常量时没有提供值，该常量的值将是不确定，且无法更改。

3. 浮点数
浮点数就是表示小数点部分的数字。计算机将值分为两部分存储，一部分表示值，另一部分则用于对值进行放大或缩小。

3.1 为什么叫浮点数？
因为小数点可移动，所以称之为“浮点数”。

表示方法：
第一种 使用常用的表示法标准小数点
3.14159
10.0
第二种 表示浮点值的方法叫做E表示法（科学计数法）。
例如：
3.45E6 3.45与10的6次方相乘，E6代表的是10的6次方。
E适合表示非常大和非常小的数。

E表示法确保数字以浮点格式存储，即使没有小数点。
指数为负数意味着除以10的乘方，而不是乘以10的乘方。
8.33E~4表示：8.33 / 10的4次方，也就是：0.000833

技巧：
1.d.dddE+n ———— 将小数点向右边移动n位
2.d.dddE-n ———— 将小数点向左边移动n位

3.2 浮点数类型
根据可以表示的有效数位和允许的指数最小范围，可以分为3种浮点数类型：float、doublelong和double。 

3.3 浮点常量
在书写浮点常量的时候，加 ， 以便区分何种类型，从而确定可表示的数值范围。例如：后缀

3.14f // float类型
3.14L // 长浮点型long double

3.4 浮点数优缺点
两个优点：
1.表示整数之间的值
2.有缩放因子
缺点：浮点数运算的速度通常比整数运算慢，而且精度完全降低。

4. C++算术运算符
五种基本运算符进行基本的算术运算。
加（+）、减（-）、乘（*）、除（/）、求模（%）
运算符的优先级和数学中的优先级类似。

4.1 除法运算符问题的总结
除法运算符（/）的行为取决于操作数的类型。
如果两个操作数都是整数，则C++将执行整数除法。把结果的小数部分丢弃，使最后的一个结果是一个整数。
如果其中有一个（或两个）操作数是浮点数，则小数部分将保留，结果为浮点数。

#include<iostream>
using namespace std;

int main()
{
    // 如果编译器不接受self()中的ios_base,请使用ios。   
    cout.setf(ios_base::fixed,ios_base::floatfield);
    cout<<"整数消除： 10 / 5 = "<<10/5<<endl; /*输出结果：10 / 5 = 2*/
    cout<<"浮点数消除：10.0 / 5.0 = "<<10.0/5.0<<endl; /*输出结果：10.0 / 5.0 = 2.000000*/
    cout<<"浮点数消除：10.0 / 5 = "<<10.0/5<<endl; /*输出结果：10.0 / 5 = 2.000000*/
    cout<<"double常量：1.e7 / 9.0 = "<<1.e7 / 9.0<<endl; /*输出结果：1.e7 / 9.0 = 1111111.111111*/
    cout<<"浮点常量：1e7f / 9.0f = "<<1.e7f / 9.0f<<endl; /*输出结果：1e7f / 9.0f = 1111111.125000*/
    return 0;
}

运算符重载：使用相同的符号进行多种操作。

4.2 求模运算符
求模（求余）：整数除法返回的余数。
与整数除法结合，适用于解决要求讲一个量分成的整数单元的问题

浮点数没有求模运算。

4.3 类型转换
类型转换的规则
1.将一种算术类型的值赋给另一种算术类型的变量时，C++对值转换为接收变量的类型。
2.表达式中包含不同的类型时，C++对值进行转换
3.将参数传递给函数时，由函数原型控制，C++对值进行转换

类型的强制转换
强制转换本身不会修改变量本身，而是创建一个新的、指定类型的值。
强制转换的通用格式如下：

(typename) value //来源于C语言
typename (value) // C++

4.4 C++11中的声明auto
在初始化声明中，如果使用关键字auto时，而不指定变量的类型，编译器将把变量的类型设置成与初始值相同。

auto n = 100; /*自动设置为int类型*/
auto x = 1.15; /*自动设置为double类型*/

第四章
1. 数组概述
1.1 数组的定义
数组（array）是一种数据格式，能够存储多个同类型的值。每个值都存储在一个独立的数组元素中，计算机在内存中依次存储数组的各个元素。
数组声明的三个特点：
1.存储在每个元素中的值的类型
2.数组名
3.数组中的元素数
C++中可以通过修改简单变量的声明，添加中括号（其中包含元素数目）来完成数组声明。
例如：

short days[24]; // 一天有24个小时

1.2 数组的声明
声明数组的的一般语法格式为：

// 数组类型 数组名字[数组的大小]
int score[4]; // 四个人的分数，整型数组

数组的大小是元素的数目指定，必须是整型常数或const值，也可以是常量表达式（8*sizeof（int））

1.3 复合类型的数组
可以使用其他的类型来创建（C语言使用术语：派生类型）
数组的用途，可以单独访问数组元素。方法是使用下标或索引来对元素进行编号。
编译器不会检查下标是否有效，所以要注意下标合法性，避免程序异常问题。 C++使用索引的方括号表示法来指定数组元素。

1.4 数组的初始化规则
1.只有在定义数组时才能初始化，此后不能使用，也不能将一个数值赋给另一个数组。
2.初始化数组时，提供的值少于数组的元素数目。
3.如果只对数组的一部分进行初始化，则编译器把其他元素设置为0。
4.如果初始化为{1}而不是{0}，则第一个元素被设置为1，其他元素都被设置为0.
5.如果初始化数组方括号内为空（[]），C++编译器将计算元素个数。例如：短东西[] = {1,3,5,7};

1.5 C++11数组初始化方法
C++11将使用大括号的初始化（列表初始化）作为一种通用的初始化方式，可用于所有类型。
在C++中列表初始化就增加了一些功能：
1.初始化数组时，可省略等号（=）
double earnings[4] {1.2e4,1.6e4,1.1e4,1.7e4};

2.可不在大括号内包含任何东西，这会将所元素都设置为零。
unsigned int const[10] = {};
float balances[100] {};

3.列表初始化禁止缩窄转换。
long num[] = {25,92,3.0}; // 浮点数转换为整型是缩窄操作
例子：

#include<iostream>

using namespace std;

int main()
{
    // 创建一个名字为yams的数组，包含了3个元素，编号是0～2.
    int yams[3];
    yams[0] = 7;
    yams[1] = 8;
    yams[2] = 6;

    // 使用逗号分隔的值列表（初始化列表），然后用花括号括起来即可。
    // 列表中的空格是可选的，如果没有初始化函数中定义的数组，其元素值也是不确定。
    int yamcosts[3] = {1,2,3};

    cout<<"yams 数组是："<<yams[0]+yams[1]+yams[2]<<endl;
    cout<<"yams[1] = "<<yams[1]<<endl;
    int total = yams[0] * yamcosts[0] + yams[1] * yamcosts[1];
    total = total + yams[2] * yamcosts[2];
    cout<<"total yam = "<<total<<endl;

    // sizeof运算符返回类型或数据对象的长度（单位为字节）。
    // 如果将sizeof运算符用于数组名，得到的是整个数组的字节数。
    // 如果sizeof用于数组元素，得到的是元素的长度（单位为字节）。
    cout<<"\n yams数组的大小 = "<<sizeof(yams)<<" Bytes.\n";
    cout<<"一个元素的大小 = "<<sizeof(yams[0])<<" Bytes.\n";

    return 0;
}

2. 字符串
字符串是存储在内存的连续字节中的一系列字符。

2.1 C++处理字符串的两种方式：
C语言，常常被称为C-风格字符串(C-style String)
以空字符（\0，ASCII码对应为0）来标记字符串的结尾。

基于String类库的方法
存储在连续字节中的一系列字符意味着可以将字符串存储在中char数组。其中每个字符都位于自己的数组元素中。
使用引号括起来的字符串，这种字符串叫 字符串常量（String constant） 或 字符串字面值（string literal） 。
字符串常量（使用双引号）不能与字符常量（使用单引号）互换。
例如：

char name[] = "Soler";

确定了存储字符串所需的最短数组时，不要忘记把包括在内。结尾的空字符

2.2 字符串常量的拼接
方法：直接两个引号括起来的字符串合并为一个。任何两个由空白（空格、制表符和换行符）分隔的字符串常量都将自动拼接成一个。

cout<<"My name is " "Soler HO.\n" 

2.3 在数组中使用字符串
将字符串存储到数组的常用方法：
1.将数组初始化为字符串常量
2.将键盘或文件输入读入到数组中。

#include <iostream>
#include <cstring> /*提供strlen()函数*/
using namespace std;

const int Size = 15;

int main()
{
    char name1[Size];
    char name2[Size] = "C++owboy";
    // 字符串的拼接
    cout<<"Howdy!I'm "<< name2;
    cout<<"!,What's your name?\n";
    cin>>name1;

    cout<<"Well, "<<name1<<",your name has : "<<strlen(name1)<<" letters and is stored!\n" ;
    cout<<"In an array of "<<sizeof(name1)<<" Bytes\n";
    cout<<"Your iniatial is "<<name1[0]<<".\n"; // name1数组中的第一个元素
    name2[3] = '\0';
    cout<<"Here are the first 3 characters of my name:"<<name2<<endl;

    return 0;
}

strlen() 函数和sizeof()运算符的区别
1.strlen()函数
返回的是存储在数组中的字符串的长度，而不是数组本身的长度。
strlen()只计算可见的字符，而不把空字符计算在内。
2.sizeof() 运算符
1.指出变量或数据类型的字节大小。
2.可用于获取类、结构、共用体和其他用户自定义数据类型的大小。

2.4 读取一行字符串的输入
解决没有逐行读取输入的缺陷。
istream中提供了面向行的类成员函数：getline()和get()函数

2.4.1 面向行的输入：getline()
使用通过回车键输入的换行符来确定输入结尾。使用cin.getline()。

函数有两个参数：
第一个参数：存储输入行的数组名称。
第二个参数：要读取的字符数（注意包含结尾的空字符（\0））。

格式：

cin.getline(name,ArSize);

2.4.2 面向行的输入：get()
与getline()函数类似，接受的参数相同，解释参数的方式也相同，并读到行尾。
区别： 读取get()并丢弃换行符，将其留在输入队列中。

格式：

cin.get(name,ArSize);

get() 将两个类成员函数拼接（合并）：

cin.get(name,ArSize).get();

get() 函数读取空行后设置会失效，输入会被阻断。可用如下恢复：

cin.clear();
混合输入数字和面向行的字符串会导致的问题：无法输入地址。
解决方法：直接使用get()进行读取之前丢弃换行符。

3. string类
string类位于名称空间std中，所以需要提供using指令或者是直接使用std::string进行引用。
要使用string类，必须在程序中包含头文件string。
string类定义隐藏了字符串的数组性质。

3.1 string对象的方式
使用string对象的方式和使用字符数组相同。
C-风格字符串来初始化string对象中。
使用cin来将键盘输入存储到string对象中。
使用cout来显示string对象。
可以使用数组表示方法来访问存储在string1对象中的字符。

赋值 —— 不能将一个数组赋给另一个数组，但可以将一个string对象赋另一个string对象。

char char01[20];                // 创建一个空列表
char char02[20] = "Jason";      // 创建一个初始化数组

string str01;                   // 创建一个空的string对象
string str02 = "Soler Ho";      // 创建一个初始化的string对象

char01 = char01;                // 不可执行，一个数组不能赋值给另一个数组
str01 = str02;                  // 可执行，可将一个string对象赋给另一个string对象。

3.2 复制、拼接和附加
string类简化字符串合并操作。
1.利用运算符 + 将两个string对象合并起来。
string str01;                  
string str02 = "Soler Ho";

string = str01 + str02;

2.可以使用运算符 +=将字符串附加到string对象的末尾。 
string str01;                  
string str02 = "Soler Ho";

str01 += str02;

4. 结构简介
结构是用户定义的类型，而结构声明定义了类型的数据属性。
定义类型之后，就直接创建类型的变量。
结构比数组灵活，同一个结构中可以存储多种类型的数据。

4.1 创建结构的步骤：
1.定义结构描述 —— 描述并标记能够存储在结构中的各种数据类型
2.按描述创建结构变量（结构数据对象）。

4.2 结构的定义：

struct(关键字) 类型名(标记成为新类型的名称)
{
    结构成员1;
    结构成员2;
    结构成员3;
};//(结束结构声明)

对于结构中的成员，使用成员运算符（.）来进行访问各个成员。

4.3 结构的初始化（C++11）
与数组一样，列表的初始化用于结构，且等号（=）可有可无。

infor Soler_infor {"Soler HO",55,168}; // 在C++11中，= 号可以省略

如果大括号内未包含任何东西，各个成员都将设置为零。

infor Soler_infor {};

不允许缩窄转换
C++允许在声明结构变量时省略关键字struct。

4.4 成员赋值
成员赋值（memberwise assignment）：可以使用赋值运算符（=）将结构赋另一个同类型的结构。这样结构中的每个成员都将被设置为另一个结构中相应成员的值。即使成员是数组。这种方式就是成员赋值。

5. 共用体
共用体（union），也叫做联合（union）。一种构造数据类型 。
关键字：union
联合（union）：将在一起共同占用同一段内存的不同类型的数据
存储不同的数据类型，但只能同时存储其中的一种类型

示例：

union sample
{
    int int_val;
    long long_val;
    double double_val;
};

5.1 结构体和共用体的区别
1.结构可以同时存储int、long和double。
2.共用体只能存储int、long和double三种。
3.含义不同。
4.关键字不同
   结构体：struct
   共用体：union
5.2 共用体的用途：
1.当数据使用两种格式或更多格式（但不会同时使用）时，可以节省空间。
   嵌入式系统编程（如控制烤箱、MP3播放器），内存非常宝贵。
2.常用于操作系统数据结构或硬件数据结构。

5.3 匿名共用体
匿名共用体（anonymous union），其成员将成为没有名称位于相同地址处的变量。

6. 枚举
C++的enum工具提供了另一种创建符号常量的方式，可以代替const，允许定义新类型，但必须有严格限制。
使用enum的语法格式与结构的使用类似。

enum color{red,orange,yellow,green,blue,voilet};

6.1 设置枚举量的值

enum week{Monday = 1,Tuesday = 2;Wednesday = 3;Thursday = 4};

指定的值必须是整数。也可以只显式地定义其中一些枚举量的值

如果第一个变量未初始化，默认为0。后面没有被初始化的枚举量的值将比其前面的枚举量大1。也可以创建多个值相同的枚举量。

enum {zero,null = 0,numero_one,one = 1};

6.2 枚举的取值范围
每个枚举都有取值范围的上限，通过强制类型转换，可以将取值范围中的任何整数值赋给枚举常量，即使这个值不是枚举值。

6.3 取值范围的定义
1.找出上限，需要知道枚举量的最大值。
   找到大于最大值的，最小的2的幂，减去1，得到就是取值范围的上限。
2.计算下限，知道枚举量的最小值。
   如果不小于0，则取值范围的下限为0，否则，采用寻找上限方式相同的方式，但是要加上负号。
对于选择使用多少空间来存储枚举由编译器决定。

7. 指针和自由空间
对于地址显示结果是十六进制表示法，因为内存的表示法都是常常描述。
指针与C++基本原理
面向对象编程和传统的过程性编程的区别，OOP强调的是运行阶段(而不是编译阶段)进行决策。
1.运行阶段：程序正在运行是，取决于不同的情况。
2.编译阶段：编译器将程序组合起来时。坚持原先设定的安排
指针用于存储值的地址。指针名表示的是地址。
*运算符称为间接值或解除引用运算符，将其应用于指针，得到该地址处存储的值。

7.1 声明和初始化指针
指针的声明必须指定指向的数据的类型。

int *p_updates; 
*p_updates 的类型是int，因为*运算符被用于指针，所以p_updates变量必须是指针。
运算符*两边的空格是可选的。

int *ptr; /*该情况强调：*ptr是一个int类型的值。*/
int* ptr; /*该情况强调：int* 是一种类型，指向int的指针。*/

在C++中，int*是一种复合类型，是指向int的指针。

double *tax_ptr;

7.2 指针的危险
在C++创建指针时，计算机将分配用来存储地址的内存，但是不会分配用来存储指针所指向的数据的内存。
一定要在对指针应用之前解除引用运算符(*)，将指针初始化为一个确定的、适当的地址。

7.3 指针和数字
整数可以加减乘除等运算，而指针描述的是位置。
C++语言数字不能作为地址使用，如果要把数字当地址来使用，应通过强制类型转换将数字转换为适当的地址类型。

7.4 使用和内存new分配delete释放
指针在运行阶段分配未命名的内存以存储值。然后使用内存来访问内存。
C语言中，使用 **库函数malloc()**来分配内存。C++中使用 ———— new运算符。

7.4.1 要注意使用delete进行内存的释放
需要内存时，直接使用new来请求，这是内存管理数据包的一个方面。
如果使用了delete运算符，使得在使用完内存后，能够将其归还给内存池，这是有效使用内存的关键。
使用delete时，后面要加上指向内存块的指针。

int * ps = new int; // 使用new进行内存分配
 ...

delete ps; // 使用delete进行内存的释放

注意点：
1.使用delete释放ps的内存，但是不会删除指针ps本身。
2.只能用delete来释放使用new分配的内存。然而，对空指针使用delete是安全的。

使用delete的关键在于，将它用于new分配的内存。这并不意味着要使用用于new的指针，而是用于new的地址
警告：不能创建两个指向同一个内存块的指针。会增加错误地删除同一个内存块两次的可能性。

7.5 使用new创建动态数组
C++中，创建动态数组，只需要将数组的元素类型和元素数目告诉new即可。必须在类型名后面加上方括号，其中包含了元素数目。
通用格式：

Type_name *pointer_name = new Type_name[num_element];
//例子
int * psome =new int[10]; // 创建10个int元素的数组

new运算符会返回第一个元素的地址
如果使用完new分配的内存，使用delete进行内存的释放。

delete [] psome; // 进行内存的释放

delete和指针直接的方括号告诉程序，应释放整个数组，不仅仅是指针指向的元素。
delete中的方括号的有无取决于使用new时的方括号有无。
对于指针数组的使用，直接可以按照普通数组的使用即可。

7.6 使用new和delete时，要遵循的规则
1.不要使用delete来释放不是new分配的内存。
2.不要使用delete释放同一个内存块两次。
3.如果使用new[]为数组分配内存时，则应使用delete[]来释放。 
4.如果使用new[]为一个实体分配内存，则应使用delete（没有方括号）来释放。
5.对空指针使用delete时很安全。

8. 指针、数组和指针算术
指针和数组基本等价的原因：指针算术(pointer arithmetic)和C++ 内部处理数组的方式。
1.将整数变量加1后，其值将增加1；
2.将指针变量加1后，增加的量等于它指向的类型的字节数。

double * pw = wages; // 数组名 = 地址 ;将pw声明为指向double类型的指针。然后将其初始化为wages - - - wages数组中第一个元素的地址。

short * ps = &wages[0]; // 使用地址操作；使用地址运算符来将ps指针初始化为stacks数组的第一个元素。

8.1 指针问题小结
8.1.1 声明指针
要声明指向特定类型的指针，语法格式：

TypeName *pointerName;
// 例子
double * pn; // pn 指向一个double类型
char * ps;  // ps 指向一个char类型

8.1.2 给指针赋值
将内存地址赋给指针。可以对变量名应用& 运算符，来获得被变量名的内存地址，new运算符返回未命名的内存的地址。
示例：

double * pn;  // pn 指向一个double类型
double * pa; // pa 指向一个double类型

char * pc; // pc 指向一个char类型
double bubble = 3.2; 

pn = &bubble; // 把bubble的地址赋值给 pn
pc = new char; // 新建char地址并分配给pc

8.1.3 对指针解除引用
对指针解除引用意味着获得指针指向的值。

方法1：对指针应用引用解除或间接值运算符(*)来解除引用。

cout<<*pn;
*pc = 's';

方法2：使用数组表示法。不可以对未初始化为适当地址的指针解除引用。

8.1.4 数组名
多数情况下，C++将数组名视为数组的第一个元素的地址。

int tacos[10]; // 此时的tacos同样也是&tacos[0]

8.1.5 指针算术
C++中允许指针和整数相加。加1的结果等于原来的地址值加上指向的对象占用的总字节数。
也可以将一个指针减去另一个指针，获得两个指针的差。得到一个整数，仅当两个指针指向同一个数组(也可以指向超出结尾的一个位置)时，这种情况会得到两个元素的间隔。

8.1.6 数组的动态联编和静态联编
使用数组声明来创建数组时，将采用静态联编，即数组长度在编译时设置。

int tacos[10] // 静态联编

使用创建数组时，将采用new[]运算符，即将在运行时为数组分配空间，其长度为运行动态联编(动态数组)时设置。
使用这类数组后，要使用delete[]释放所占用的内存。

8.1.7 数组表示法和指针表示法
使用方括号数组表示法等同于对指针解除引用。
数组名和指针变量也是一样。所以对于指针和数组名，既可以使用指针表示法，也可以使用数组表示法。

int * pt = new int [10];
*pt = 5;
pt[0] = 6;
pt[9] = 5;
int coats[10];
*(coats + 4) = 12;

8.2 指针和字符串
数组名是第一个元素地址。
如果给cout提供一个字符的地址，则它将从该字符开始打印，直到遇到空字符为止。
在cout和多数C++表达式中，char数组名、char指针以及用引号括起来的字符串常量都被解释为字符串第一个字符的地址。
不要使用字符串常量或未被初始化的指针来接收输入。
在字符串读入程序时，应使用已分配的内存地址。该地址不是数组名，也可以使用new初始化过的指针。
strcpy()接受两个参数,第一个：目标地址，第二个：要复制的字符串的地址。
要确定目标空间有足够的空间来存储副本。

8.3 使用new创建动态结构
对于在指定结构成员时，句点运算符和箭头运算符的选择时：

如果结构标识符是结构名，则使用句点运算符（.）。
如果标识符是指向结构的指针，则使用箭头运算符（->）。

把new用于结构的两个步骤
1.创建结构
   要创建结构，需要同时使用结构类型和new。
2.创建访问其成员。

8.4 C++管理数据内存的方式
自动存储 在函数内部定义的常规变量使用自动存储空间，称为自动变量。
只在特定函数被执行时存在。

自动变量时一个局部变量，作用域为包含它的代码块。通常存储在栈中，遵循后进先出（LIFO）。

静态存储
变量称为静态的方式
在函数外面定义
在声明变量时使用关键字static。
整个程序执行期间都存在的存储方式（存在于程序的整个生命周期）。

动态存储 内存池（自由存储空间或堆）用于静态变量和自动变量，且内存是分开的。

线程存储（C++11特性）

9. 数组替代品 --- 模板类
模板类vector和array是数组的替代品。

9.1 模板类向量
模板类vector类似于string类，也是一种动态数组。
vector对象包含在vector头文件中。
vector包含在名称空间std中，使用using编译指令、using声明或std::vector。
模板使用不同的语法来指出它存储的数据类型。
vector类使用不用的语法来指定元素数。

9.2 模板类数组（C++11）
std位于名称空间中，与数组一样，array对象的长度固定，也使用栈（静态内存分配），而不是自由存储区。
头文件 array。

9.3 数组、vector和array的区别
无论是数组、vector对象还是array对象，都可使用标准数组表示法来访问各个元素。
从地址可知，array对象和数组存储在相同的内存区域（即栈）中，vector对象存储在自由存储区域或堆中。
可以将一个array对象赋给另一个array对象，对于数组，必须逐个元素复制数据。

第16章
1. 字符串类
C语言在 string.h（C++中为cstring）提供了一系列的字符串函数。

1.1 构造字符串
string 实际上是模板具体化 basic_string<char>的一个typedef，同时省略了与内存管理相关的参数。
size_type 依赖于实现的整型，是头文件 string在中定义的。
string类将string::npos定义为字符串的最大长度，通常为unsigned int的最大值。

1.2 string类输入
在C-风格字符串，有3种方式：

char info[100];
cin >> info;            // 读取字符
cin.getline(info,100); // 整行读取，舍弃 \n
cin.get(info,100);      // 整行读取，保留 \n

对于string对象，有2种方式：

string stuff;
cin >> stuff;       // 读取字符
getline(cin,stuff); // 读取整行内容，舍弃\n

两个版本的getline() 都有一个可选参数，用于指定使用某个字符来确定输入的边界。

// 读到 : 就舍弃 :
cin.getline(info,100,':');
getline(stuff,':');

对于string版本的getline()函数从输入读取字符，并将其存储到string对象中，直到发生三种情况之一：
1.到达文件尾，在这种情况下，输入流的eofbit将被设置，这意味着方法fail( )和eof( )都将返回true；
2.遇到分界字符（默认为\n），在这种情况下，将把分界字符从输入流中删除，但不存储它；
3.读取的字符数达到最大允许值（string::npos和可供分配的内存字节数中较小的一个），在这种情况下，将设置输入流的failbit，这意味着方法fail( )将返回true。

输入流对象有一个统计系统，用于跟踪流的错误状态。
1.系统中如果检测到文件尾后将设置eofbit寄存器。
2.检测到输入错误时将设置failbit寄存器。
3.出现无法识别的故障时将设置badbit寄存器。
4.一切顺利则设置goodbit寄存器。

1.3 使用字符串
string类对象对全部 6个关系运算符都进行了重载。
1.如果在机器序列中，一个对象位于另一个对象的前面，则前者小于后者
2.如果机器序列为ASCII码，则小写数字大于大写字符。
通过确定字符串的长度来比较大小，使用size()和length()成员函数返回字符串中的字符数。

if (snake1.length() == snake2.size())
    cout << "both strings have the same lengt \n";

在字符串中搜索给定的子字符串或字符。

方法原型	方法描述
size_type find(const string &str, size_type pos = 0) const	从字符串的pos位置开始，查找子字符串str，如果找到，则返回子字符串首次出现时其首字符的索引，否则返回 string::npos
size_type find(const char * s,size_type pos = 0)const	从字符串的pos位置开始，查找子字符串s，如果找到，则返回子字符串首次出现时其首字符的索引，否则返回 string::npos
size_type find(const char *s,size_type pos = 0,size_type n)	从字符串的pos位置开始，查找s的前n个字符组成的子字符串，如果找到，则返回子字符串首次出现时其首字符的索引，否则返回 string::npos
size_type find(char ch, size_type pos = 0)const	从字符串的pos位置开始，查找字符串ch，如果找到，则返回字符出现的，否则返回 位置string::npos
string库提供了相关的方法（其重载函数特征标都与find()方法相同。）：
rfind()：查找子字符串或字符最后一次出现的位置。
find_first_of()：在字符串中查找参数中任何一个字符首次出现的位置。
find_last_of()：在字符串中查找参数中任何一个字符最后一次出现的位置。
find_first_not_of()：在字符串中查找不在参数中的字符第一次出现的位置。
find_last_not_of()：在字符串中查找不在参数中的字符最后一次出现的位置。
+=运算符的某个重载版本使得能够将一个字符附加到字符串中。

1.4 字符串的额外函数方法
capacity()：返回当前分配给字符串的内存块的大小。
reserve()：能够请求内存块的最小长度。

1.5 字符串种类
string类看作是基于char类型模板的具体化

// Allocator 是管理内存分配的类，对于各种字符类型，都有预定义的allocator模板具体化，都是默认的，使用new和delete。
template <class charT, class traits = char _traits<charT>,
        class Allocator = allocator<charT> > 
basic_string {...};

模板 basic_string 有4个具体化，每一具体化都有一个 typedef名称：

typedef basic_string<char> string;
typedef basic_string<wchar_t> wstring;
typedef basic_string<char16_t> u16string; // C++11
typedef basic_string<char32_t> u32string; // C++11

2. 智能指针模板类型
智能指针是行为类似于指针的类对象。

目的：将开发者将申请未释放的内存回收，从而避免内存泄漏。

2.1 使用智能指针
智能指针类一共有3种：
auto_ptr
unique_ptr
shared_ptr

将new获得（直接或间接）的地址赋给这种对象。当智能指针过期时，其析构函数将使用delete来释放内存。
如果将new返回的地址赋给对象后，无需关注释放内存。当智能指针过期时，内存将自动释放。

auto_ptr 和常规指针在行为方面的差别：share_ptr和unique_ptr的行为与auto_ptr相同。

使用常规指针实现：

void remodel(std::string &str)
{
  std::string * ps = new std::string(str);
  ...
  if(weird_thing())
    throw exception();
  str = *ps;
  // 如果出现异常，delete不会被执行，会导致内存泄漏
  delete ps;
  return;
}

使用智能指针的3个步骤：
包含头文件memory
将string的指针指向替换为指向string的智能指针对象
删除语句delete
所以将remodel()函数使用智能指针重写为：

#include <memory>
void remodel(std::string & str)
{
  std::auto_ptr <std::string> ps (new std::string(str));
  ...
  if (weird_thing())
    throw exception();
  str = *ps;
  // 不需要delete ps;语句
  return;
}

2.2 智能指针的注意事项
auto_ptr 和unique_ptr都是采用所有权模型。
unique_ptr时，程序不会等到运行阶段崩溃，而是在编译器阶段就出现错误。
使用引用计数的shared_ptr是绝对稳定安全。

// auto_ptr 会在运行阶段出现 segmentation fault (core dumped)
auto_ptr<string> p1 (new string("auto"));
auto_ptr<string p2>;
p2 = p1; // p2会接管string对象的所有权后，p1的所有权会被剥夺

// unique_ptr 会在编译阶段出现 segmentation fault (core dumped)
unique_ptr<string> p3 (new string("unique"));
unique_ptr<string p4>;
p4 = p3;

所以unique_ptr相对比auto_ptr更加安全。可以直接就在编译阶段解决在运行阶段会出现的潜在问题。

重要的注意点：
1.使用new分配内存时，才能使用auto_ptr和shared_ptr，使用new[ ]分配内存时，它们不能使用；
2.不使用new分配内存时，不能使用auto_ptr或shared_ptr；
3.不使用new或new[ ]分配内存时，不能使用unique_ptr。
unique_ptr 可以用于数组的变体。

2.3 如何选择智能指针？
1.unique_ptr：程序不需要多个指向同一个对象的指针。 
   如果编译器没有unique_ptr，可以使用Boost库中的scoped_ptr。
2.shared_ptr：程序需要使用多个指向同一个对象的指针。
   指针数组中使用辅助指针来标识特定的元素。
   两个对象包含都指向第三个对象的指针
   STL容器包含指针
   如果编译中没有shared_ptr，可使用Boost库提供的shared_ptr。
3.auto_ptr：在满足unique_ptr要求的条件时，也可使用auto_ptr，但unique_ptr是更好的选择。

3. 标准模板库
STL提供的模板

容器：一个与数组类似的单元，可以存储若干个值。STL容器是同质，即存储的值的类型相同。
迭代器：用来遍历容器的对象，与可遍历数组的指针类似，是广义指针。
函数对象：类似函数对象，可以是类对象或者函数指针。
算法：完成特定任务处方。

3.1 模版类vector
STL通过在头文件vector中定义了vector模板，使其类成为通用的。
创建vector模板对象，使用通常的 表示法来指出要使用的类型。vector模板使用动态内存分配，所以可以用初始化参数来指出多少矢量。

#include <vector>
vector<int> rating(5);
int n;
cin >> n;
vector<double> scores(n);

使用[] 运算符来访问 vector元素。

3.2 可对vector执行的操作
size()：返回容器中元素数目
swap()：交换两个容器的内容
begin()：返回一个指向容器中第一个元素的迭代器
end()：返回一个表示超过容器尾的迭代器。
迭代器：一个广义指针。每个容器类都定义了一个合适的迭代器，迭代器的类型为：iterator 的 typedef，其作用域为整个类。

声明一个迭代器变量的语法如下：

vector<double>::iterator pd; // pd 是迭代器
vector<double> scores;
// 迭代器的可进行的两个操作
pd = scores.begin();
*pd = 22.3; // 使用 * 来解引用
++pd;       // 使用 ++ 使得指针指向下一个元素

push_back()：将元素添加到vector结尾。
erase()：删除vector中给定区间的元素。
接受两个参数：
  起始位置
  终点位置
区间为左闭右开。
insert()：插入元素
  接受3个参数
   指定新元素的插入位置
   第二个和第三个为被插入区间。

3.3 STL对vecotr的其它操作
STL从更广泛的角度定义了非成员（non-member）函数来执行这些操作，即不是为每个容器类定义find( )成员函数，而是定义了一个适用于所有容器类的非成员函数find( )。这种设计理念省去了大量重复的工作。

3个具有代表性的STL函数：

1.for_each()

可用于很多个容器类，接受3个参数：
前两个是定义容器中区间的迭代器
最后一个指向函数的指针，普遍一般说最后一个参数是函数对象。
for_each() 函数将被指向的函数用于容器区间中的各个元素
被指向的函数不能修改容器元素的值
可以使用for_each()函数来代替for循环。

#include<vector>
struct Review{
  std::string title;
  int rating;
};
vector<Review> book;
vector<Review>::iterator pr;
vector<Review>::iterator pr;
for (pr = books.begin(); pr != books.end();pr++)
  ShowReview(*pr);

// 使用for_each修改为：
for_each(books.begin(),books.end*()); // 可以避免显式地使用迭代器变量

2.random_shuffle()

接受两个指定区间的迭代器参数，并随机排列区间中的元素。

random_shuffle(books.begin(),books.end());

要求容器类允许随机访问，例如vector类。

3.sort()

也要求容器支持随机访问。
函数的两个版本：
版本1:接受2个定义区间的迭代器参数，并使用 <运算符为存储在容器中的类型元素定义的，对区间中元素进行操作。

// 使用内置的<运算符
vector<int> coolstuff;
...
sort(coolstuff.begin(),coolstuff.end());
// 如果容器元素是用户定义的对象，则必须定义能够处理该类型对象的 operator<() 函数
bool operator<(const Review &r1 , const Review & r2)
{
  if (r1.title < r2.tile)
    return true;
  else if (r1.title == r2.title && r1.rating < r2.rating)
    return true;
  else
    return true;
}

版本2:接受3个参数
1.前两个参数：指定区间的迭代器
2.最后一个参数：指向要使用的函数的指针（函数对象）。

4. 泛型编程
STL是一种 泛型编程（generic programming）。
面向对象编程关注的是编程的数据方面，而泛型编程关注的是算法。
泛型编程旨在编写独立于数据类型的代码。
在C++中，完成通用程序的工具是模板。

4.1 为何使用迭代器？
模板提供了存储在容器中的数据类型的通用表示，因此还需要遍历容器中的值的通用表示，迭代器正是这样的通用表示。

迭代器应具备的特征：
1.能进行解除引用的操作，以便能够访问它引用的值。
2.迭代器之间能赋值。
3.迭代器之间能比较，判断是否相等。
4.能遍历容器中的所有元素，以便于实现++需求。

struct Node{
  double item;
  Node *p_next;
};

class iterator
{
  Node *pt;
  public:
    iterator() : pt(0) {};
    iterator (Node *pn) : pt(pn) {}
    double operator*()= {return pt->item;}
    iterator & operator++() // 前缀++
    {
      pt = pt->p_next;
      return *this;
    }
    iterator operator++(int) // 后缀++
    {
      iterator tmp = *this;
      pt = pt->p_next;
      return tmp;
    }
    ...
};

作为一种编程风格，最好避免直接使用迭代器，应尽可能使用STL函数（如for_each()）来处理细节。也可以使用C++11新增的基于范围的for循环。

for (auto x : scores) cout << x << std::endl;

4.2 迭代器的类型
不同的算法对迭代器的要求也不同。

1.查找算法
需要定义++运算符，以便迭代器能遍历整个容器。
要求能读取数据，但不要求能写数据。
2.排序算法
能够随机访问，便于两个不相邻的元素交换。
如果是iter，则可以通过迭代器定义+运算符来实现随机访问。

STL定义了5种迭代器
1.输入迭代器
被程序用来读取容器中的信息
能访问容器中所有的值，通过支持++运算符来实现。
单向通行，算法只读
2.输出迭代器
将信息从程序传输给容器的迭代器，因此程序的输出就是容器的输入。
单向通行，算法只写
3.正向迭代器
只使用++运算符来遍历容器，每次沿容器向前移动一个元素。
可读可写，如果要使得只读，可使用const关键字。
4.双向迭代器
典型函数： 翻转操作reverse()
正向迭代器具备的所有特性。
支持两种（前缀和后缀）递减运算符
5.随机访问迭代器
有些算法（如标准排序和二分检索）要求能够直接跳到容器中的任何一个元素，这叫随机访问，需要随机访问迭代器。
具备双向迭代器的所有特性。
5种迭代器可执行解除引用操作（已定义*运算符），可进行比较（看是否相等，使用了==运算符）

4.3 迭代器的层次结构
由于迭代器之间都是后者支持了前者的全部功能，也有自己的功能.
每个容器类都定义了一个类级typedef名称——iterator，因此vector<int>类的迭代器类型为vector<int> :: interator。

4.4 概念、改进和模型
概念可以具有类似继承的关系。概念的具体实现叫做模型（model）。指向int的常规指针是一个随机访问迭代器模型，也是一个正向迭代器模型，因为它满足该概念的所有要求。

4.4.1 将指针用作迭代器
迭代器是广义指针，而指针满足所有的迭代器要求。
迭代器是STL算法的接口，而指针是迭代器，因此，STL算法可以使用指针来对基于指针的非STL容器进行操作。
STL sort() 函数接受指向容器第一个元素的迭代器和指向超尾的迭代器作为参数。

const int SIZE = 100;
double Receipts[SIZE];
sort(Receipts, Receipts + SIZE); // 等价于 sort(&Receipts[0],&Receipts[SIZE])

copy() ： 将数据从一个容器复制到另一个容器中，通过迭代器的方式实现。

前两个参数是要赋值的范围（输入迭代器），最后一个参数是要复制到的位置（输出迭代器）。
不能使用 copy将数据放到空vector中。
如果有一个输出流表示的迭代器，可以用copy()。STL为模板提供了 ostream_iterator模板。

适配器（adapter） ---- 一个类或函数。适配器的作用：将一些接口转换为STL使用的接口：可以通过包含头文件<iterator>来实现。

1.ostream_iterator 适配器

#include <iterator>
...
// 第一个参数：int 指出被发送给输出流的数据类型
// 第二个参数：char 指出了输出流使用的字符类型。
// out_iter中的第一个参数：要使用的输出流
// out_iter中的第二个参数：分隔符
ostream_iterator<int, char> out_iter(cout," ");
// out_iter 是一个接口

// 使用解引用的方式对迭代器进行操作
*out_iter++ = 15; // 相当于 cout << 15 << " ";

2.istream_iterator

// 使用两个 istream_iterator 对象来定义 copy() 的输入范围
copy(istream_iterator<int,char>(cin),
    istream_iterator<int,char>(),dice.degin());
// 第一个参数：指出要读取的数据类型
// 第二个参数：指出输入流使用的字符类型

4.4.2 其它迭代器
除了 istream_iterator、ostream_iterator 之外，还有一些专用的预定义迭代器类型。

reverse_iterator：执行递增操作将导致它被递减。
只能允许用于尾部快速插入的容器
back_insert_iterator：将元素插入到容器尾部
front_insert_iterator：将元素插入到容器的前端
只能用于允许在起始位置做时间固定插入的容器类型。
insert_iterator：将元素插入到 insert_iterator 构造函数的参数指定的位置前面。
无限制
后三种（back_insert_iterator、front_insert_iterator、insert_iterator）通过将复制转换为插入来解决不知道长度或者不覆盖已有内容的问题。原因：只做插入新元素的操作，所以不会覆盖已有数据，并使用自动内存分配来确保可以容纳新的数据信息。

back_insert_iterator<vector<int> > back_iter(dice);
insert_iterator<vector<int> > insert_iter(dice,dice.begin() );

示例：

#include <iostream>
#include <string>
#include <iterator>
#include <vector>
#include <algorithm>

void output(const std::string & a) {std::cout << s << " ";}

int main()
{
  using namespace std;
  string s1[4] = {"fine","fish","fashion","fate"};
  string s2[2] = {"busy","bate"};
  string s3[2] = {"silly","singer"};
  vector <string> words(4);
  copy(s1,s1 + 4,words.begin()); // 将s1中的4个字符串复制到words中
  for_each(words.begin(),words.end(),output);
  cout << endl;
  // 构造匿名对象 back_insert_iterator
  // 将s2的元素插入到末尾，而且words的长度扩增到6个元素
  copy(s2,s2+2,back_insert_iterator<vector<string> (words)>);
  for_each(word.begin(),words.end(),output);
  cout << endl;
  // 构造 匿名对象 insert_iterator
  // 将s3中的元素插入到words第一个元素的前面，words的长度被增加到8个元素
  copy(s3,s3+2,insert_iterator<vector<string> >(words,words.begin()));
  for_each(words.begin(),words.end(),output);
  cout << endl;
  return 0;
}

4.5 容器种类
STL具有容器概念和容器类型。
概念是具有名称（如容器、序列容器、关联容器等）的通用类别。

4.5.1 容器类型
1.可用于创建具体容器对象的模板。
2.C++11 之前有11个
deque、list、queue、priority_queue、stack、vector、map、multimap、set、multiset和bitset
3.C++11中新增5个
forward_list、unordered_map、unordered_multimap、unordered_set 和 unordered_multiset

4.5.2 容器概念
1.容器概念指定了所有STL容器类都必须满足的一系列要求。
2.容器是存储其他对象的对象。被存储的对象必须是同一种类型的，可以是OOP意义上的对象，也可以是内置类型值。
3.存储在容器中的基本类型必须满足：是可复制构造和可赋值的。
4.只要类定义没有将可复制构造函数和赋值运算符声明为私有或保护的。
“复杂度”：描述了执行操作所需的时间。
5.编译时间：在编译时执行，执行时间为0
6.固定时间：发生在运行阶段，但独立于对象中的数目
7.线性时间：时间与元素数目成正比。

4.5.3 容 器序列（sequence）
7种STL容器类型：deque、C++11新增的forward_list、list、queue、priority_queue、stack和vector都是序列。
队列可以在队尾添加元素，在队首删除元素。
deque表示的双端队列允许在 两端添加和删除元素。
序列要求其元素按严格的线性顺序排列，即存在第一个元素、最后一个元素、除第一个元素和最后一个元素外，每个元素前后都有一个元素。
数组和链表是序列，但是分支结构不是。
在情况允许下，复杂都是固定时间。

vector
模板头文件 vector
是数组的一种类表示
提供自动内存管理概念，可以动态改变vector对象的长度，随着元素的添加和删除而增大和减小。
在尾部复杂度是：固定时间
在头部或中间复杂度：线性时间
支持可反转容器（reversible container）的两个类方法
1.rbegin()：返回一个指向反转序列的第一个元素的迭代器
2.rend()：返回反转序列的超尾迭代器
3.强调随机快速访问

deque
模板头文件 deque
双端队列（double-ended queue）
在STL中，类似vector，支持随机访问。
一般发生在起始和结尾处的操作，考虑使用deque

list
模板头文件 list
双向链表
list在链表中任一位置进行插入和删除的复杂度都固定
元素的快速插入和删除
list不支持数组表示法和随机访问
sort()、merge()、unique() 和remove()方法

forward_list（C++11）
实现了单链表
单链表的特点：每个节点都只链接到下一个节点，而没有链接到前一个节点。
是一个正向迭代器

queue
模板头文件 queue
是一个适配器类
不允许随机访问队列元素，不允许遍历队列
使用限制在定义队列的基本操作上，可以将元素进行如下操作：
1.添加到队尾
2.从队首删除元素
3.查看队首和队尾的值
4.检查元素数目
5.测试队列是否为空

priority_queue
模板头文件 queue
是一个适配器类
与queue主要区别： 在priority_queue中，最大元素被移到队首，内部区别在于，默认的底层是 vector
可修改用于确定哪个元素放到队首的比较方法

priority_queue<int> pq1; // 使用priority_queue默认方式 排序
priority_queue<int> pq2(greater<int>) // 使用greater<int> 排序

stack
头文件 stack
是一个适配器类
不允许随机访问栈元素，也不能遍历栈。
基本操作和queue类似。

4.6 关联容器（associative container）
关联容器是对容器概念的另一个改进。
关联容器将值与键关联在一起，并使用键来查找值。
优点：提供对元素的快速访问。允许插入新元素，但不能指定插入的位置。关联容器通常是用于确定数据放置的算法。
基于树（数据结构）来实现。
树的概念：其根节点链接到一个或两个节点，节点再次分支。

STL提供4种关联容器
1.头文件 set
set
set的类型与键相同，且键唯一。不会有相同的元素，对于set来说，值就是键。
multiset
2.类似set，一个键可能有多个值。
头文件 map
map
值与键的类型不同，键是唯一的
每一个键只对应于一个值。
multimap
类似map，一个键可与多个值相关联。

4.7 无序关联容器（C++11）
无序关联容器是对容器概念的另一种改进。
关联容器基于树结构实现，而无序关联容器是基于数据结构哈希表来实现。旨在提高添加和删除元素的速度以及提高查找算法的效率。
4种无序关联容器：
unordered_set
unordered_multiset
unordered_map
unordered_multimap

5. 函数对象
很多STL算法都使用函数对象 ---- 也叫 函数符（functor）。
函数符是可以以函数方式与( )结合使用的任意对象。这包括函数名、指向函数的指针和重载了( )运算符的类对象（即定义了函数operator( )( )的类）。

在for_each方法中，第三个参数不能声明函数指针，所以for_each 模板原型为：

template<class InputIterator, class Function>
Function for_each(InputIterator first, InputIterator last, Function f);

5.1 函数符概念
STL定义了容器和迭代器的概念，也定义了函数符的概念
1.生成器（generator）是不用参数即可调用的函数符。
2.一元函数（unary function）是用一个参数可以调用的函数符
3.二元函数（binary function）是用两个参数可以调用的函数符
4.返回bool值的一元函数是谓词（predicate）
5.返回bool值的二元函数是二元谓词（binary predicate）。

5.2 预定义的函数符
STL定义了多个基本函数，它们执行诸如两个值相加、比较两个值是否相等的操作。提供这些函数对象是为了支持将函数作为参数的STL函数。

头文件 定义了多个模板类函数对象，其中包括了 。functionalplus>()

#include <functional>
...
plus<double> add; // 创建一个 plus<double> 对象
double y = add(2.2,3.4); //使用 plus<double>::operator()()

5.3 自适应函数符号和函数适配器
函数符成为自适应的原因：携带标识参数类型和返回类型的。这些成员是：typedef成员
result_type
first_argument_type
second_argument_type

函数符自适应的意义在于：函数适配器对象可以使用函数对象，并认为存在这些typedef成员。

6. 算法
STL包含很多处理容器的非成员函数。

sort()
copy()
find()
random_shuffle()
set_union()
set_intersection()
set_difference()
transform()
整体设计思想：都使用 迭代器来标识要处理的数据区间和结果的放置位置。

对于算法函数设计：

都使用模板来提供泛型。
都使用迭代器来提供访问容器中数据的通用表示。

6.1 算法组
STL将算法库分成4组：
头文件 algorithm

1.非修改式序列操作
对区间中的每个元素进行操作。不修改操作容器的内容。
如find()和for_each()
2.修改式序列操作
对区间中的每个元素进行操作。
可修改容器内容（包括修改值、修改值的排列顺序）
如transform()、random_shuffle()、copy()
3.排序和相关操作
包含多个排序函数和其它各种函数，包括集合操作
如 sort()

头文件 numeric
4.通用数字运算
包括将区间的内容累积、计算两个容器的内部乘积、计算小计、计算相邻对象差的函数。
一般是数据的操作特性。

6.2 算法的通用特征
对算法分类的方式之一就是按结果放置的位置来进行分类。

有些算法有两个版本：
1.就地版本
sort() 函数完成时，将结果存放到原始数据的位置上
2.复制版本
copy() 函数将结果发送到另一个位置
transform() 可以是两个版本。

STL中约定：复制版本的名称将以_copy()来结尾。复制版本接受一个额外的输出迭代参数，参数指定结果的放置位置。

6.3 STL和string类
string类虽不是STL的组成部分，但是设计string时考虑到了STL。其中的begin()、rbegin()、end()和rend()等成员函数，都可以使用STL接口。

6.4 函数和容器方法
有时可以选择使用STL方法或者STL函数，通常方法是更好的选择。
1.方法适合于特定的容器
2.方法作为成员函数，它可以使用模板类的内存管理工具，从而调整容器的长度。

例如，假设是数字组成链表，要删除特定值的所有实例

la.remove(4); // 删除值为4的所有元素，删除后链表的长度也会被自动调整

尽管方法通常是更适合，但非方法函数更通用。
非方法函数可以用于数组、string对象、STL容器，可用来处理混合的容器类型。

7. 其它库
头文件complex为复数提供了类模板complex，包含用于float、long和long double的具体化。这个类提供了标准的复数运算及能够处理复数的标准函数。
C++11新增的头文件 random 提供了更多的随机数功能。
valarray头文件提供的模板类valarray，类模板被设计用于数值数组，支持各种数值数组操作。

7.1 vector、valarray和array
C++中提供的3个数组：
vector
valarray
array

7.1.1 vector
vector模板类 是一个容器类和算法系统的一部分，支持面向容器的操作。如排序、插入、重新排列、搜索、将数据转移到其它容器中等。

7.1.2 valarray
valarray类模板是面向数值计算的，但不是STL的一部分。它没有push_back()和insert()方法。但为很多数学运算提供了一种简单、直观的接口。
假设要计算数组中每个元素的自然对数，并将计算结果存储到另一个数组的相应元素中，STL方法如下：

transform(ved1.begin(),ved1.end(),ved3.begin(),log);

valarray类重载了数学函数，使之接受一个valarray参数，并返回一个valarray对象，所以可以：

ved3 = log(ved1); // log() 重载

也可以使用 apply() 方法，适用于非重载函数：

ved3 = ved1.apply(log);

valarray 类提供了方法：
sum()：计算valarray对象中所有元素的和
size()：返回元素数
max()：返回最大的元素值
min()：返回最小的元素值

C++11提供了接受valarray对象作为参数的模板函数begin()和end()。

sort(begin(vad),end(vad)); // C++11 fix

7.1.3 array
array 为替代数组而设计，通过提供更好、更安全的接口，让数组效率更高。

Array表示长度固定的数组，它不支持push_back()和insert()，但提供了STL方法，包括begin()、end()、rbegin()和rend()。

7.2 模板initializer_list（C++11）
头文件initializer_list

initializer_list模板是C++11新增。如果类有接受initializer_list作为参数的构造函数，一般使用表示法{ }而不是()来调用类构造函数。

shared_ptr<double> pd = {new double}; // 使用 {} 来代替 ()

// 所有的initializer_list 元素的类型都必须相同，如果不相同，编译会进行必要的转换
std::vector<double> payments {45.99,39.23,19,89}; 
// 其中的 19和89 会被转换成double类型,不能隐式的窄化转换（double不能转换为int）
std::vector<double> payments {45.99,39.23,19.0,89.0};

第17章
1. C++输入和输出概述
C实现自带了一个标准函数库，C++自带了一个标准类库。标准类库是一个非正式的标准，是由头文件 iostream 和 fstream 中定义的类组成。

1.1 流、缓冲区和iostream
C++程序把输入和输出看作字节流。
输入时
程序从输入流中抽取字节
输出时
程序把字节插入到输出流中

输入流中的字节可能来自键盘、存储设备或者其它程序。
输出流中的字节可以流向屏幕、打印机、存储设备或者其它程序。

管理输入包含两步：
将流与输入去向的程序关联起来
将流与文件连接起来。

通常，通过使用缓冲区可以高效地处理输入和输出。缓冲区是用作中介的内存块 。它将信息从设备传输到程序或从程序传输给设备的 临时存储工具。

头文件iostream 中包含了一些专门设计用来实现管理流和缓冲区的类。
1.streambuf类 为缓冲区提供了内存，并提供了用于填充缓冲区，访问缓冲区内容，刷新缓冲区和管理缓冲区内存的类方法。
2.ios_base类 表示流的一般特征，如是否可读取，是二进制还是文本流等。
3.ios类基于ios_base，其中包含了一个指向streambuf对象的指针成员。
4.ostream类 是基于ios类派生而来，提供输出方法。
5.istream类 也是基于ios类派生而来，提供输入方法。
6.iostream是基于 istream 和 ostream类，基础了输入和输出方法。

在程序中包含 iostream 文件，将自动创建8个流对象（4个用于窄字符流，4个用于宽字符流）

1.处理窄字符流 ----- 处理 char_t 类型
cin对象对应于标准输入流。
cout对象与标准输出流相对应。
cerr对象与标准错误流相对应，用于显示错误信息。流不会被缓冲。
clog对象对应标准错误流。流会被缓冲。

2.处理宽字符流 ----- 处理 wchar_t 类型
wcin对象
wcout对象
wcerr对象
wclog对象

1.2 重定向
标准输入和输出流通常连接键盘和屏幕。
输入重定向（<）
输出重定向（>）

2. 使用cout进行输出
C++将输出流看作字节流。平台不同，则读取字节流会有差异。
ostream类最重要的任务之一：将数据内部表示（二进制位模式）转换为由字符字节组成的输出流，使能够直接翻译成二进制数据。
在C++中，<< 运算符的默认含义是按位左移运算符。但ostream类重新定义了 << 运算符，方法将其重载为输出（也称为 插入运算符）。
插入运算符的所有化身的返回类型都是 ostream&。原型格式如下：

ostream & operator<<(type);

除了 operator<<() 函数外，ostream类还提供 put() 方法和 write() 方法。前者用于显示字符，后者用于显示字符串。

put()方法
原型如下：

// 参数：提供要显示的字符
ostream &put(char);

write()方法
原型如下：
// 第一个参数：提供要显示字符串的地址
// 第二个参数：指出要显示多少个字符
basic_ostream<charT, traits> & write(const char_type* s, streamsize n);

write() 方法不会在遇到空字符时自动停止打印字符，而只是打印指定数目的字符，即使超出字符串的边界。
都是类成员函数，需要有调用对象

cout.put('w');
cout.write("Kansas",6);

ostream类对cout对象处理的输出进行缓冲，所以输出不会立即发送到目标地址，而是被存储到缓冲区中，直到缓冲区填满。然后程序将刷新缓冲区，把内容发送出去，并清空缓冲区，以存储新的数据。

如果实现不能在所希望时刷新输出，可以使用强制刷新的两个控制符之一：
flush：刷新缓冲区
endl：刷新缓冲区，并插入一个换行符

cout << "Hello, good-looking !" << flush;
cout << "Wait just a moment, please ." << endl;

ostream插入运算符将值转换为文本格式。在默认情况下，格式化值的方式如下：
1.char值：如果代表的是可打印字符，则将被作为一个字符显示在宽度为一个字符的字段中。
2.数值整型：将以十进制方式显示在一个刚好容纳该数字的字段中。
3.字符串：显示在宽度等于该字符串长度的字段中
4.浮点类型：浮点类型被显示为6位，末尾的0不显示
   数字以定点表示法显示还是科学计数法表示，取决于值。
   当指数大雨6或者小于等于-5时，将使用科学计数法。 
   字段宽度恰好容纳数字和负号。

2.1 修改显示时使用的计数系统
ostream类从ios类派生而来，而ios从ios_base类派生而来。ios_base类存储了描述格式状态的信息。
通过使用 ios_base 的成员函数，可以控制字段和小数位数。。因ios_base类时ostream的间接基类，可以将其方法用于ostream对象。
要控制整数以十进制、十六进制还是八进制显示，可以使用 dec、hex 和 oct 控制符。

dec(cout);   // 十进制，等价于  cout << dec;
hex(cout);   // 十六进制，等价于 cout << hex;
oct(cout);   // 八进制，等价于 cout << oct;

使用上述设置后，程序将以十六进制形式打印整数值，直到将格式状态设置为其它选项为止。注意：控制符不是成员函数，不必通过对象来调用。

2.2 调整字段宽度
由于数字的字段宽度不同，所以可以使用 width 成员函数将长度不同的数字放到宽度相同的字段中。方法原型为：

int width(); // 返回字段宽度的当前设置
int width(int i); // 将字段宽度设置为 i 个空格，并返回以前的字段宽度值

width() 方法只影响将显示的下一个项目，然后字段宽度将恢复为默认值。

C++永远不会截短数据，会增宽字段，以容纳该数据。C/C++的原则 ：显示所有的数据比保持列的整洁更重要，C++视内容重于形式。

int main()
{
  cout.width(5);
  cout << "N" << ":";
}

2.3 填充字符
在默认情况下，cout 使用空格填充字段中未被使用的部分，可以使用 fill() 成员函数来改变填充字符。

cout.fill('*');

对于检查结果，防止接收方添加数字很有用。

2.4 设置浮点数的显示精度
浮点数精度的含义取决于输出模式。在默认模式下，指的是显示的总位数。
在定点模式和科学模式下，精度指的是小数点后的位数。
C++中的默认精度为6位（末尾的0将不显示），precision() 成员函数使能够选择其他值。

cout.precision(2); // 设置精度为2，设置后一直有效，只有重新设置会被重置

2.5 打印末尾的0或小数点
使用 setf() 函数，能够控制多种格式化特性：

cout.setf(ios_base::showpoint); // 默认精度是6位

使用默认的浮点格式时，会将导致末尾的0被显示出来。

2.6 setf()
ios_base类有一个受保护的数据成员，其中的各位分别控制着格式化的各个方面。
对于setf() 函数，有两个原型：

// 此为原型1
fmtflags setf(fmtflags);

fmtflags 是 bitmask类型的typedef名，用于存储格式标记。
因都是 ios_base类中定义，所以使用时，必须加上作用域解析运算符。
bitmask 类型是一种用来存储各个位值的类型。可以是整型、枚举，也可以是STL bitset容器。

在C++标准中，定点表示法和科学表示法都有两个特征：
1.精度指的是小数位数，而不是总位数
2.显示末尾的0

第二种 setf() 函数的原型：

// 第一个参数：包含所需设置的fmtflags值
// 第二个参数：指出要清除第一个参数中的那些位
fmtflags setf(fmtflags,fmtflags);

例如，要左对齐，则使用：

ios_base::fmtflags old = cout::setf(ios::left, ios::adjustfield);
如果要恢复以前的设置，则使用，

cout.setf(old,ios::adjustfield);

在调用setf() 后可以通过unsetf() 来消除，unsetf() 的原型如下：

// mask 是位模式，mask中是所有的位都设置为1，将使得对应的位被复位
void unsetf(fmtflags mask);

2.7 头文件iomanip
C++ 在头文件 iomanip中提供了一些控制符。其中3个最常用的控制符分别是：

setprecision()：设置精度
接受一个指定精度的整数参数

setfill()：填充字符
接受一个指定填充字符的char参数

setw()：字符宽度
接受一个指定字段宽度的整数参数

3. 使用cin进行输入
cin对象将标准输入表示为字节流，通常情况下，通过键盘来生成这种字符流。

3.1 cin>>如何检查输入
不同版本的抽取运算符查看输入流的方法都是相同的。他们跳过空白（空格、换行符和制表符），直到遇到非空白字符。

单字符模式
>> 运算符将读取该字符，将它放置到指定的位置
其他模式
>> 运算符将读取一个指定类型的数据。

3.2 流状态
流状态（被定义为isolate类型，而isolate是一种bitmask类型）。由3个ios_base元素组成：
eofbit：表示到达文件末尾
badbit：遇到无法诊断的失败破坏流
failbit：未能读取到预期的字符

其中的每个元素都是一位，可以是1（设置）或0（清除）。当3个状态位都被设置为0时，说明一切顺利。

clear() 和 setstate() 类型，都是重置状态，但采取的方式不同。
clear()：将状态设置为它的参数
setstate()：只影响其参数中设置的位置，而不会影响其他位。

exceptions() 方法返回一个位字段，包含3位，分别对应于eofbit、failbit、badbit。修改流状态涉及clear() 或 setstate() ，都将使用clear()。当前状态中的对应位也被设置，则clear() 将引发 ios_base::failure 异常。如果两个值都设置了badbit，将发生这种情况。
exceptions() 的默认设置为 goodbit，没有引发异常，但重载的 exceptions(isolate) 函数使得能够控制其行为。

cin.exceptions(badbit);

位运算符OR 使能够指定多位。

cin.exceptions(badbit | eofbit);

设置流状态位将对后面的输入或者输出关闭，直到位将被清除。

while (cin >> input)
{
  sum += input;
}
// 可以在此处增加 clear() 来清除流状态
//cout.clear();
cin >> input; // don't work

如果希望程序在流状态位被设置后能够读取后面的输入，就必须将流状态设置为良好。可以通过调用 clear() 来实现。导致输入循环终止的不匹配输入仍留在输入队列中，程序必须跳过它。

3.3 其他istream类方法
方法get(char&) 和 get(void) 提供不跳过空白的单个字符输入功能
函数 get(char*, int, char) 和 getline(char*, int, char)在默认情况下读取整行而不是一个单词。
都称为 非格式化输入函数。都只是读取字符输入，而不会跳过空白，也不进行数据转换。

对于 >>、get(char &) 或者 get(void)的选择问题上，确定是否跳过空格，如果跳过空白则使用抽取运算符>>。
get() 方法会检查程序每个字符。
对于字符串的输入成员函数，getline() 成员函数和 get() 的字符串读取版本都读取字符串，他们的函数特征标相同。

// 第一个参数：放置输入字符串的内存单元的地址
// 第二个参数：比要读取的最大字符数大1
// 第三个参数：指定用做分界符的字符
istream & get(char *, int, char);
istream & get(char *, int);
istream & getline(char *, int, char);
istream & getline(char *, int);

对于get() 和 getline() 方法的区别：
get()：将换行符留在输入流中
getline()：抽取并丢弃输入流中的换行符。

特殊的成员函数 ignore()，函数原型表示：

istream & ignore(int = 1,int = EOF); // 原型中的两个参数提供的默认值为 1 和 EOF。

默认参数值EOF导致 ignore() 读取指定数目的字符或读取文件尾。

3.4 其他istream方法
read()：读取指定数目的字节，并将其存储在指定的位置中。不会在输入后加上空值字符。
peek()：返回输入中的下一个字符，但不抽取输入流中的字符。
gcount()：返回最后一个非格式化抽取方法读取的字符数。
putback()：将一个字符插入到输入字符串中，被插入的字符将是下一条输入语句读取的第一个字符。

4. 文件输入和输出
C++ I/O类软件包处理文件输入和输出的方式与处理标准输入和输出的方式相似。
要写入文件，需要创建一个ofstream对象，并使用ofstream方法。
要读取文件，需要创建一个ifstream对象，并使用ifstream方法。

4.1 简单的文件I/O
要让程序写入文件的做法：
创建一个ofstream对象来管理输出流
将该对象与特定的文件关联起来
以使用cout的方式使用该对象，唯一的区别是输出将进入文件，而不是屏幕。

读取文件的做法：
创建一个ifstream对象来管理输入流
将该对象与特定的文件关联起来
以使用cin的方式使用该对象
当输入和输出流对象过期（如程序终止）时，到文件的连接将自动关闭，另外，也可以使用 close() 方法来显式地关闭到文件的连接。关闭连接并不会删除流，只是将流重新连接到同一个文件或者另一个文件。

ifstream fin;
ofstream fout;
fout.close();
fin.close();

4.2 流状态检查和is_open()
C++文件流从 ios_base 类那里继承了一个流状态成员。
在C++通过使用 is_open() 方法 来检查文件是否被成功打开。

4.3 命令行处理技术
文件处理程序通常是使用命令行参数来指定文件。命令行参数是用户在输入命令时，在命令行中输入的参数。
C++中在命令行环境中运行的程序能够访问命令行参数的机制

// argc：命令行中的参数个数
// argv：变量为一个指针，指向一个指向char的指针。argv[0] 表示指向一个参数（字符串指针）
int main(int argc, char *argv[])

4.4 文件模式
文件模式描述的是文件将被如何使用：读、写、追加等。
ios_base类定义了一个 openmode 类型，用于表示模式。
位运算符OR（|）：将两个位值合并成一个可用于设置两个位的值。

ofstream fout("bageis",ios_base::out | ios_base::app);

在 ios_base::out 本身将导致文件将被截短，但与 ios_base::in 一起使用时，不会导致文件被截短，没有列出的组合。

ios_base::ate 和 ios_base::app 都将文件指针指向打开的文件结尾。区别之处：
ios_base::app：将指针放到文件尾
ios_base::ate：只允许数据添加到文件尾。

数据存储在文件中，是两种形式：
文本格式：将所有的内容都存储为文本。
二进制格式：将存储值的计算机内部表示。

计算机不是存储字符，而是以二进制的形式存储。
文件两种存储形式的优缺点
1.文本格式
优点
便于读取
使用编辑器或字符处理器来读取和编辑

2.二进制格式
优点
不会有转换误差或者舍入误差
保存速度快，不需要转换
可以大块存储数据。
数据特征不同，空间占用小
缺点
换系统或者OS会导致无法正常使用

要以二进制格式（而不是文本格式）存储数据，可以使用 write() 成员函数。

将文件使用二进制的格式：

fout.write((char *) &pl, sizeof pl)
// 将pl地址强制转换为指向char的指针
// sizeof() 获取字节数

要使用文件恢复信息，则使用通过 ifstream对象 使用相应的 read() 方法：

ifstream fin("planets.dat",ios_base::in | ios_base::binary);
fin.read((char *) &pl,sizeof pl);

read() 和 write() 成员函数的功能是相反，一般使用 read() 来恢复 write() 写入的数据。

4.5 随机存取
随机存取指的是直接移动（不是依次移动）到文件的任何位置。
随机存取常被用于数据库文件，程序维护一个独立的索引文件。文件指出数据在主数据文件中的位置。
需要在一种文件中移动的方式，ifstream类继承的两个方法：
seekg()：将输入指针移到指定的文件位置。
可用于 ifstream 对象
seekp()：将输出指针移到指定的文件位置。
可用于 ofstream对象

seekg() 的原型：

basic_istream<charT, traits> & seekg(off_type, ios_base::seekdir);
basic_istream<charT, traits> & seekg(pos_type);

// 将 char 具体化
istream & seekg(streamoff, ios_base::seekdir); // 定位到离第二个参数指定的文件位置特定距离（单位为字节）的位置
istream & seekg(streampos); // 定位到离开文件开头特定距离（单位为字节）的位置

5. 内核格式化
头文件 sstream 定义了一个从 ostream类派生来的ostringstream类。如果创建了一个ostringstream对象，则可以将信息写入其中，并将其信息存储。
istringstream 和 ostringstream类使得能够使用 istream 和 ostream 类的方法来管理存储在字符串中的字符数据。
