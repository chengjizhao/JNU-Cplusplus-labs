阅读的书籍是c++primer第5版中文版
第一章：
第一章主要介绍了C++的大部分基础内容：类型、变量、表达式、语句以及函数。并在讲解这些内容的过程中，简要的介绍了如何编译以及运行程序。
其中的介绍C++输入的内容让人记忆深刻，以往学习的C语言常常指定输入数据的数量，而C++能够读取数量不定的输入数据，给它一串输入数据只有在遇到文件结束符或遇到一个
无效的的输入时istream对象的状态才会变为无效。
另外第一章还介绍了一个经典的程序——书店程序，这个程序和本次的作业有些像，它可以统计并实时更新每本书的交易量，就和统计同学们每次成绩一样，只不过这里没有文件读
取与写入的功能。
第一章只是介绍些基础内容，大部分与C语言类似，难度并不大，理解起来也不是很困难。

第二章：
第二章详细的介绍了C++语言的几种内置的数据类型，并带领读者初步了解C++如何支持更复杂的数据类型。
基本内置类型
这一节详细介绍了C++支持的基本内置类型,包括整型(char、short、int、long、long long)、浮点型(float、double、long double)、布尔型(bool)和空类型(void)。书中给
出每种类型占用的存储空间大小,取值范围等信息。如int类型通常为32位,取值范围是-2147483648~2147483647。不同的整型类型占用存储空间不同,取值范围也有区别。
变量
这一节讲解了变量的声明和定义。变量是程序中用于存放数据的地方。声明变量时要指定变量类型,可以用初始化器给变量一个初值。使用变量前必须先进行声明,而且只能在声明
后才能使用。变量可以是自动存储类型(局部变量)或静态存储类型(全局变量)。局部变量存放在栈中,作用域为当前代码块,用完自动释放。全局变量的生命周期为整个程序运行期
。建议优先使用局部变量。
类型转换
C++支持隐式类型转换(系统自动转换)和强制类型转换。强制转换需要使用强制类型转换运算符(type)value,可能会损失信息,应谨慎使用。C++还提供四种强制转换:static_cast
、const_cast、reinterpret_cast和dynamic_cast。静态强制转换static_cast可以对兼容类型进行转换。
字面值常量
字面值常量是写在代码中的一个固定值,如10,3.14等。可以加类型修饰符控制其类型。如果函数的参数全是常量表达式,可以使用constexpr标识成一个常量表达式。
定义常量
可以使用const和constexpr定义常量。const修饰的变量为只读变量,不可以再修改值。constexpr定义编译期常量,必须使用常量表达式初始化。应优先使用constexpr定义符号常
量。
这一章都是比较固定的一章，了解记住即可。
第三章：
第三章详细的介绍了字符串、向量和数组，这部分比较抽象。
 字符串：
C++使用string类封装和管理字符串,包含在头文件string中
string是一个类,代表字符的集合,可以对其进行初始化、赋值、拷贝、追加等操作
可以通过下标访问string中的个别字符,下标从0开始
string末尾有一个隐含的空字符'\0'作为结束标记
string类管理字符串空间分配和释放,程序员不需要操心管理细节
应该用string类替代C语言中的字符数组表示字符串
向量vector：
 vector是C++标准模板库的一个容器,封装了一个动态大小数组
 头文件vector中定义了向量类模板vector
 可以用vector容纳各种类型的对象,元素能快速随机访问
 初始化或赋值会复制元素,比较向量内容要用equal函数
 可以通过调用push_back在向量尾部插入元素
 可以调用pop_back删除最后一个元素
 可以使用迭代器访问和遍历向量中的元素
 向量容量可以动态增长
 数组：
 数组是同一类型元素的固定大小序列,占用连续内存
 C++支持静态数组和动态数组：
 数组元素可以通过下标索引访问,越界会导致严重后果
 C++扩展了C语言数组,能验证下标并捕获越界异常
 数组作为函数参数会退化为指针,丢失大小信息
 多维数组：
 C++支持多维数组，可以指定每个维度大小定义多维数组
 用初始化列表初始化多维数组
 遍历打印多维数组需要递增嵌套循环
 数组和指针：
 数组通过指针进行底层实现；数组名就是指向首元素的指针常量；指针和数组名都可以当做指针使用；指针运算可以遍历数组,访问元素；用指针可以动态改变数组大小
 C字符串函数：
 C++继承了C语言字符串处理函数,在cctype等头文件中；C风格字符串函数参数为char*,传入string需要使用data()

第四章：
第四章介绍了常用的基本运算符。
算术运算符、逻辑和关系运算符、赋值运算符、递增和递减运算符、成员访问运算符、条件运算符、位运算符、sizeof运算符等等

第16-18章：
这部分还没有看完，不太理解，找了些定义的基本资料
1. 函数模板
函数模板利用参数化类型,使函数能够以泛型方式处理多种类型,模板参数通常是类型参数。定义函数模板时,使用 typename 指定泛型类型参数,也可以有非类型参数。调用时
根据实参类型及值,编译器自动实例化出适配的函数。可以显式指定类型实例化模板,也可以依据参数自动类型推断实例化。
2. 类模板
类模板基于一组参数化类型定义泛型类,可以参数化类的数据成员、成员函数的类型。利用类模板可以轻松定义泛型容器、算法等库。类模板与函数模板语法类似,在关键字后
指定类型参数。类模板实例化后生成类类型,可以按类的方式定义对象。
3. 模板参数
模板参数用于表示泛型类型或值,可以有多种形式:类型参数通常采用大写字母表示,非类型参数采用小写字母表示,还可以指定默认参数值。也可以定义模板模板参数,它指定
一个类或函数模板。
4. 模板实例化
编译器使用类或函数模板去生成新的类或函数,这个过程称为模板实例化。实例化时将参数类型及值替换模板参数,并检查 substituted 参数类型的有效性。实例化后,模板
的代码与普通类和函数没有区别。
5. 成员模板
类内可以直接声明模板成员函数或类模板成员函数,它们可以灵活处理类内多个类型的数据成员。成员模板通过 this 指针可以直接访问类中其他成员。
6. 模板偏特化
可以为部分特定类型自定义模板的实现版本,而非通用参数化版本,这称为模板偏特化。全特化是重定义模板所有参数的具体实现。偏特化优先匹配 before 一般模板。
7. 模板技巧
一些高级模板用法包括:对函数模板进行偏特化、使用 typeof 或 decltype 获取表达式类型、使用子类继承控制实例化等技巧。
8. 可变参数模板
可变参数模板使用模式声明不定个数的参数,扩展了模板表达能力。参数包使用省略号表示,递归展开参数包实现重复调用。
