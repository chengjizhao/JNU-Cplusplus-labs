第一章
C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。C++ 是 C 的一个超集，任何合法的 C 程序都是合法的 C++ 程序。C++作为静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。C++最大的亮点就是面向对象程序设计理念的运用。包括面向对象开发的四大特性： 封装 抽象 继承 多态。标准的 C++ 由三个重要部分组成： 核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。 C++ 标准库，提供了大量的函数，用于操作文件、字符串等。 标准模板库（STL），提供了大量的方法，用于操作数据结构等。

第二章 开始学习 C++
看了些练习题

第三章 处理数据
面向对象编程（OOP）的本质是设计并扩展自己的数据类型。设计自己的数据类型就是让类型与数据匹配。
内置的C++类型分两组：基本类型和复合类型。
3.1 简单变量
把信息存储在计算机中，程序必须记录3个基本属性：信息将存储在哪里；要存储什么值；存储何种类型的信息。
在 C++ 所有主观的风格中，一致性和精度是最重要的。
简单的 C++ 命名规则：在名称中只能使用字母字符、数字和下划线 ( _ )；名称的第一个字符不能是数字；区分大写字符与小写字符；不能将C++关键字用作名称；以两个下划线 或 下划线+大写字母 打头的名称被保留给实现（编译器及其使用的资源）使用；以 一个下划线 开头的名称被保留给实现，用作全局标识符；C++对于名称的长度没有限制，名称中所有的字符都有意义，但有些平台有长度限制。
3.1.2 整型
不同C++整型使用不同的内存量来存储整数。使用的内存量越大，可以表示的整数值范围也越大。C++的基本整型（按宽度递增的顺序排列）分别是char、short、int、long和long long，其中每种类型都有符号版本和无符号版本，因此总共有10种类型可供选择。
如果不对函数内部定义的变量进行初始化，该变量的值将是不确定的。这意味着该变量的值 将是它被创建之前，相应内存单元保存的值。
3.1.4 无符号类型
要创建无符号版本的基本整型，只需使用关键字 unsigned 来修改声明即可。unsigned本身是unsigned int的缩写。
3.1.5 选择整型类型
通常，int被设置为对 目标计算机而言最为“自然”的长度。自然长度（natural size）指的是计 算机处理起来效率最高的长度。如果没有非常有说服力的理由来选择其 他类型，则应使用int。如果short比int小，则使用short可以节省内存。通常，仅当有大型整型数组时，才有必要使用short。如果只需要一个字节，可使用char。
3.1.8 char类型：字符和小整数
char类型是专为存 储字符（如字母和数字）而设计的。char类型是另一种整型。C++对字符用单引号，对字符串使用双引号。 cout对象能够处理这两种情况。与int不同的是，char在默认情况下既不是没有符号，也不是有符号。如果将char用作数值类型，则unsigned char和signed char之间的差异将非常重要。unsigned char类型的表示范围通常为0～255，而signed char 的表示范围为−128到127。
3.2 const 限定符
C++有一种比 #define 更好的处理符号常量的方法，这种方法就是使用 const 关键字来修改变量声明和初始化。常量（如Months）被初始化后，其值就被固定 了，编译器将不允许再修改该常量的值。如果您这样做，g++将指出程 序试图给一个只读变量赋值。关键字const叫做限定符，因为它限定了声明的含义。（#define 定义符号常量的方式应抛弃。）如果在声明常量时没有提供值，则该常量的值将是不确定的，且无法修改。
3.3 浮点数
计算机将这样的值分成两部分存储。一部分表示基准值，另一部分用于对值进行放大或缩小。
3.4.4 类型转换
更安全的转换方式是使用 static_cast<typeName> (value) 函数

第四章 复合类型
数组（array) 是一种数据格式，能够存储多个同类型的值。每个值都存储在一个独立的数组元素中，计算机在内存中依次存储数组的各个元素。即一个数组所在的内存区域是连续的。
要创建数组，可使用声明语句。数组声明应指出以下三点：存储在每个元素中的值的类型；数组名；数组中的元素数。
在C++中，通过在简单变量后面添加中括号（其中包含 元素数目）来完成数组声明。而数组中的每一个元素都看作是一个简单变量。声明数组的通用格式为 :typeName arrayName[arraySize]
表达式arraySize指定元素数目，它必须是整型常数（如10）或const 值，也可以是常量表达式（如8 * sizeof（int）），即其中所有的值在编 译时都是已知的。具体说，arraySize不能是变量，变量的值是在程序运行时设置的。如果没有初始化数组的值，则其元素值将是不确定的，这意味着元素的值为以前驻留在该内存单元中的值。
字符串是存储在内存的一片连续字节中的一系列字符，这里的连续是重点。 存储在连续字节中的一系列字符意味着可以将字符串存储在char数 组中，其中每个字符都位于自己的数组元素中。字符串提供了一种存储 文本信息的便捷方式。两种处理字符串的方法：（1）C-风格字符串；（2）基于 string 类的方法。
C-风格字符串具有 一种特殊的性质：以空字符（null character）结尾，空字符被写作 \0， 其ASCII码为0，用来标记字符串的结尾。空字符对 C-风格字符串而言至关重要。C++有很多处理字符串的函数，其 中包括cout使用的那些函数。它们都逐个地处理字符串中的字符，直到 到达空字符为止。
有一种更好的、 将字符数组初始化为字符串的方法—只需使用一个用引号括起的字符串 即可，这种字符串被称为字符串常量（string constant）或字符串字面值 （string literal）
使用C-风格字符串，在确定存储字符串所需的最短数组时，别忘了+1，要将结尾的空字符计算在内。
izeof运算符指出整个数组的长度：15字节，但 strlen( )函数返回的是存储在数组中的字符串的长度，而不是数组本身的长度。 另外，strlen( ) 只计算可见的字符，而不把空字符计算在内。
使用 cin 暗含两个问题:遇到空格结束；输入字符串长于目标数组。
cin使用空白 （空格、制表符和换行符）来确定字符串的结束位置，这意味着cin在 获取字符数组输入时只读取一个单词。读取该单词后，cin将该字符串 放到数组中，并自动在结尾添加空字符。
iostream 中的 get() 虽然和 getline() 类似，它们接受的参数相同，解释参数的方式也相同，并且都读取到行尾。但 get 将换行符保留在输入队列中，假设我们连续两次 调用 get( ) 那么要注意了。
第一次调用后，换行符将被留在输入队列中，因此第二次调用时看到的第一个字符便是换行符，此时 get() 以为已经到达行尾了，而没有发现任何可读取的内容。如果不借助于帮助，get() 将不能跨过该换行符。
为什么要使用 get()，而不是 getline() 呢？ 首先，老式实现没有 getline()。其次，get() 使输入更仔细。例如，假设用get( ) 将一行读入数组中。如何知道停止读取的原因是由于已经读取了整行，而不是由于数组已填满呢？ （getline，判断不了）， 查看下一个输入字符，如果是换行符，说明已读取了整行；否则，说明该行中还有其他输入。总之， getline() 使用起来简单一些，但 get( ) 使得检查错误更简单些。
string 类包含于头文件 string 并位于名称空间 std 中，使用起来比字符数组简单，它提供了将字符串作为一种数据类型的表示方法，符合 C++ 的风格。 string 类定义隐藏了字符串的数组性质，让我们能够像处理普通变量那样处理字符串。
在很多方面，使用 string 对象的方式和使用字符数组相同：可以使用 C-风格字符串来初始化 string 对象；可以使用 cin 来将键盘输入存储到 string 对象中；可以使用 cout 来显示 string 对象；可以使用数组表示法来访问存储在 string 对象中的字符。string 对象和字符数组的主要区别是，可以将 string 对象声明为简单变量，而不是数组。这使得与使用数组相比，使用string对象更方便，也更安全。从理论上说，可以将char 数组视为一组用于存储一个字符串的 char 存储单元，而 string 类变量是一个表示字符串的实体。
4.4 结构体简介
**结构体（Struct）**是 一种比数组更灵活的数据格式，因为同一个结构体可以存储多种不同类型的数据，从而将数据的表示合并到一起。
4.7 指针和自由存储空间
C++ 中 指针是一个变量，其存储的是值的地址，而不是值本身。
使用常规变量时，值是指定的量，而地址为派生量。接下来看看指针策略，它是C++内存管理编程理念的核心。
4.7.2 指针的危险
创建指针时，计算机将分配用来存储指针这个变量本身的内存，但不会分配指针所指向的数据所需的内存。为数据提供空间是一个独立的步骤，如果忽略这一步麻烦就大了。
4.7.4 使用new来分配内存
指针真正的用武之地在于，运行阶段分配未命名的内存用于存储值。C++ 通过 new 运算符为变量分配内存。
程序员要告诉new，需要为哪种数据类型分配内存；new将找到一个长 度正确的内存块，并返回该内存块的地址。程序员的责任是将该地址赋 给一个指针。
4.7.5 使用 delete 释放内存
delete 运算符，用于将不再使用的内存归还给内存池，归还或释放（free）的内存可供程序的其他部分使用。使用 delete 时，后面要加上指向内存块的指针（这些内存块最初是用new分配的）。归还 ps 指向的内存，并不会删除指针 ps 本身，它可以继续用来指向新分配的内存。 new 和 delete 一定要配对使用，否则会导致程序发生内存泄露（memory leak），即分配出去的内存拿不回来，无法再使用。
只需要将指针名当做数组名，然后按照数组的访问方式即可，C/C++ 中数组和指针是基本等价的。对于第1个元素，可以使用 psome[0]，而不是 *psome；对于第2个元素，可以使用 psome[1]，依此类推。
在很多情况下，可以相同的方式使用指针名和数组名。也就是说，使用 new 来创建数组以及使用指针来访问不同的元素时，只要把指针当作数组名对待即可。数组名被解释为其第一个元素的地址，而对数组名应用地址运算符时，得到的是整个数组的地址，区别很大。

第十六章 string类和标准模板库
看了些练习题

第十七章 输入、输出和文件
17.1 C++输入和输出概述
C++依赖于C++的I/O解决方案，而不是C语言的I/O解决方案，前者是在头文件iostream和fstream中定义一组类。
C++程序把输入和输出看作字节流。输入时，程序从输入流中抽取字节；输出时，程序将字节插入到输出流中。
输入流需要两个连接，每端各一个。文件端部连接提供了流的来源，程序端连接将流的流出部分转储到程序中（文件端连接可以是文件，也可以是设备，如键盘）。同样，对输出的管理包括将输出流连接到程序以及将输出目标与流关联起来。这就像将字节（而不是水）引入到水管中。通过使用缓冲区可以更高效地处理输入和输出。缓冲区是用作中介的内存块，它是将信息从设备传输到程序或从程序传输给设备的临时存储工具。
C++程序通常在用户按下回车 键时刷新输入缓冲区。对于屏幕输出，C++程序通 常在用户发送换行符时刷新输出缓冲区。
17.1.2 流、缓冲区和iostream文件
cin对象对应于标准输入流；
cout对象与标准输出流相对应；
cerr对象与标准错误流相对应，可用于显示错误消息。这个流没有 被缓冲，这意味着信息将被直接发送给屏幕，而不会等到缓冲区填 满或新的换行符；
17.1.3 重定向
标准输入和输出流通常连接着键盘和屏幕。重定向这个方法可以改变标准输入和标准输出。通过输入重定向（<）和输出重定向（>）可以将输入和输出重置为文件。
17.4 文件输入和输出
重定向虽然可以提供一些文件 支持，但它比显式程序中的文件I/O的局限性更大。另外，重定向来自操作系统，而非C++，因此并非所有系统都有这样的功能。
要写入文件，需要创建一个ofstream对象，并使用 ostream 方法，如 << 插入运算符或 write()。要读取文件，需要创建一个 ifstream 对象，并使用 istream 方法，如 >> 抽取运算符或 get()。
clog对象也对应着标准错误流。在默认情况下，这个流被关联到标 准输出设备（通常为显示器），这个流被缓冲；
17.4.1 简单的文件 I/O
程序写文件需要包含头文件 fstream，并这样做：声明并创建一个 ofstream 对象来管理输出流；将该对象和特定文件关联起来，open 方法；以 cout 的方式使用该对象，区别是输出将进入文件，而不是屏幕。
程序读取文件的要求与写入文件相似：创建一个 ifstream 对象来管理输入流；将该对象与特定的文件关联起来，open()方法；以使用 cin 的方式使用该对象。
