    模式体现了一个程序内部完整思想，因此它也能够跨越分析阶段和高层设计阶段。然而，因为模式常常有一个直接的代码实现，所以在底层设计或编码实现之前很难将其表示
出来.基本概念看做一般情况下程序设计的基本概念：增加一些抽象层。当人们对某事物进行抽象的时候，隔离特定的细节，最直接的动机之一是为了使变化的事物与不变的事物
分离开。按以下三种分类：1）创建型（Creational）：用于怎样创建一个对象。通常包括隔离对象创建的细节，这样代码不依赖于对象是什么类型，因此在增加一种新的对象类
型时不需要改变代码。本章将介绍单件（Singleton）模式、工厂（Factory）模式和构建器（Builder）模式。2）结构型（Structural）：影响对象之间的连接方式，确保系统
的变化不需要改变对象间的连接。结构型模式常常由工程项目限制条件来支配。本章中将看到代理（Proxy）模式和适配器（Adapter）模式。3）行为型（Behavioral）：在程序
中处理具有特定操作类型的对象。这些对象封装要执行的操作过程，比如解释一种语言、实践一个请求、遍历一个序列（如像在一个迭代器内）或者实现一个算法。本章包含命令
（Command）模式、模板方法（TemplateMethod）模式、状态（State）模式、策略（Strategy）模式、职责链（Chain ofResponsibility）模式、观察者（Observer）模式、
多派遣（Multiple Dispatching）模式和访问者（Visitor）模式的例子。其中，信使（messenger） 是这些方法中最微不足道的一个，它将消息封装到一个对象中到处传递，
而不是将消息的所有片段分开进行传递。收集参数必须有一些方法用来设置值或者插入值。注意，根据这个定义信使可以被当做收集参数来使用。单件的另外一种变体采用将一个
对象的“单件属性（Singleton-ness）”从其实现中分离出来的方法。命令（command）模式的结构很简单，但是对于消除代码间的耦合（decoupling）—清理代码—却有着重要的
影响。代理（Proxy）模式和状态（State）模式都提供一个代理（Surrogate）类。代码与代理类打交道，而做实际工作的类隐藏在代理类背后。当调用代理类中的一个函数时，
状态模式产生一个可以改变其类的对象，当发现在大多数或者所有函数中都存在有条件的代码时，这种模式很有用。和代理模式一样，状态模式通过一个前端对象来使用后端
实现对象履行其职责。适配器（Adapter）模式接受一种类型并且提供一个对其他类型的接口。模板方法模式的一个重要特征是它的定义在基类中（有时作为一个私有成员函数）
并且不能改动—模板方法模式就是“坚持相同的代码”。它调用其他基类函数（就是那些被覆盖的函数）以便完成其工作，但是客户程序员不必直接调用这些函数。职责链（Chain 
of Responsibility）模式也许被看做一个使用策略对象的“递归的动态一般化”。由于每个面向对象应用程序都需要创建对象，并且由于人们可能通过添加新类型来扩展应用程
序，工厂模式可能是所有设计模式中最有用的模式之一。多态只能通过虚函数调用来实现，所以如果想要发生多重派遣，必须有一个虚函数调用以确定每个未知的类型。因此，如
果处理的是不同层次结构的两个类型的交互作用，则每个层次结构都必须有一个虚函数调用。

