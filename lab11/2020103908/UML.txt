单例模式：
+---------------------+
|      Singleton      |
|---------------------|
| - instance: Singleton|
|---------------------|
| + getInstance(): Singleton|
| + someMethod(): void |
+---------------------+
Singleton 是包含单例模式逻辑的类。
- instance: Singleton 表示私有的静态成员变量，用于保存类的唯一实例。
+ getInstance(): Singleton 是一个公有的静态方法，用于获取类的实例。
+ someMethod(): void 是一个示例方法，表示类的其他方法。

单例模式适用于以下场合：
资源共享的情况： 当多个对象需要共享相同的资源，例如配置信息、日志文件等，使用单例模式可以确保只有一个实例访问这些资源。
控制资源访问： 当对特定资源的访问需要限制时，例如数据库连接池，可以使用单例模式确保只有一个实例管理连接。
全局对象管理： 在某些情况下，需要一个全局的唯一对象，例如线程池、缓存管理器等，可以使用单例模式来管理这些全局对象。
日志记录： 单例模式可以用于记录日志信息，确保在整个应用程序中只有一个日志实例。
线程池管理： 单例模式可以用于管理线程池，确保只有一个线程池实例。






工厂方法模式：
+-------------------------+          +-----------------------+
|      Product            |          |    Creator            |
|-------------------------|          |-----------------------|
|                         |          | + factoryMethod():    |
|                         |<-------->|   virtual Product     |
+-------------------------+          |                         |
                                    +-------------------------+
                                               ^
                                               |
                                     +------------------------+
                                     |    ConcreteProduct    |
                                     |------------------------|
                                     |                        |
                                     +------------------------+
 Product 是产品的抽象类或接口，定义了具体产品子类的通用接口。
Creator 是创建者的抽象类，其中包含一个工厂方法 factoryMethod()，它返回一个 Product 类型的对象。
ConcreteProduct 是具体产品的子类，实现了 Product 接口。
Creator 类通过调用工厂方法来创建产品。

工厂方法模式适用于以下场合：
类的实例化延迟到其子类： 当一个类不知道它所必须创建的对象的类时，可以使用工厂方法模式。这样，实际创建的对象是由子类决定的。
避免直接依赖具体类： 工厂方法模式可以通过将客户端代码与实际创建的具体类解耦，从而使系统更具有可维护性和可扩展性。
产品族的创建： 如果一个系统中存在多个相关的产品族，并且需要保证这些产品族之间的一致性，工厂方法模式是一个很好的选择。
在子类中实现创建逻辑： 工厂方法模式允许在子类中实现创建逻辑，从而使得每个子类都可以根据需要创建不同的产品。 


策略模式：
+--------------------------+       +----------------------+
|       Context            |       |      Strategy        |
|--------------------------|       |----------------------|
| - strategy: Strategy*    |       |                      |
|--------------------------|       +----------------------+
| + Context()              |              /\
| + Context(Strategy*)     |              |
| + setStrategy(Strategy*) |              |
| + executeAlgorithm()     |              |
+--------------------------+              |
              |                          |
              |                          |
              |                          |
              |                          |
              |                          |
              v                          |
       +--------------+                 |
       |   Concrete   |                 |
       |  Strategy    |                 |
       |--------------|                 |
       |              |                 |
       +--------------+                 |
Context 类包含一个指向 Strategy 接口的指针，并且可以在运行时动态地设置具体的策略。
Strategy 接口是策略族的抽象，定义了一系列的算法。
ConcreteStrategy 是 Strategy 接口的具体实现，即具体的算法。

策略模式适用于以下场合：
需要在多个算法中选择一个时： 当一个系统需要在运行时根据不同的情况选择不同的算法时，策略模式是一个有力的工具。
需要避免使用条件语句确定算法： 如果一个类有多种实现，而且这些实现之间可以相互替换而不影响客户端代码，策略模式可以帮助避免使用复杂的条件语句。
算法的实现可能经常发生变化： 当系统中的算法经常发生变化，但客户端不应该知道这些变化时，使用策略模式可以将变化封装在具体策略类中，而不影响客户端。
类具有大量的条件语句： 当一个类包含许多条件语句来选择不同的行为时，策略模式可以帮助简化代码结构，使其更清晰。



桥接模式：
+-------------------+       +------------------------+
|     Abstraction   |       |      Implementor      |
|-------------------|       |------------------------|
| - implementor:    |       |                        |
|   Implementor*    |<----->| + operationImpl(): void|
+-------------------+       +------------------------+
| + operation():    |               /\
|   void            |               |
+-------------------+               |
                |                   |
                |                   |
                v                   |
         +--------------+           |
         |   Refined    |           |
         | Abstraction  |           |
         |--------------|           |
         |              |           |
         +--------------+           |
Abstraction 是抽象部分的类，它包含一个指向 Implementor 接口的指针，并定义了一些操作。
Implementor 是实现部分的接口，定义了实现部分的操作。
Refined Abstraction 是对 Abstraction 进行扩展的类。
Concrete Implementor 是 Implementor 接口的具体实现。

桥接模式适用于以下场合：
不希望在抽象和实现部分之间建立永久的绑定关系： 桥接模式允许抽象部分和实现部分可以独立变化，而不是在两者之间建立一个静态的关联关系。
一个类存在多个独立变化的维度： 如果一个类有多个维度的变化，使用桥接模式可以避免类的指数级增长。
需要在运行时动态地选择实现： 如果系统需要在运行时选择不同的实现，桥接模式提供了一种灵活的方式来实现这一点。
实现部分对客户端透明： 如果希望实现部分对客户端透明，可以使用桥接模式，使客户端仅与抽象部分交互，而不必关心具体的实现。




