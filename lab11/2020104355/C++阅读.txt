本章介绍了设计模式的分类，共有23种设计模式，按照创造型、结构型、行为型3种目的进行分类。
创造型模式用于创建对象，通常包括隔离对象创建的细节，这样代码不依赖于对象是什么类型，因此在增加一种新的对象类型时不需要改变代码。包括单例模式、工厂模式和构建器模式；
结构型模式影响对象之间的连接方式，常常由工程项目限制条件来支配，包括代理模式和适配器模式；
行为型模式用于处理具有特定操作类型的对象，包括命令模式、模板方法模式、状态模式、策略模式、职责链模式、观察者模式、多派遣模式和访问者模式。
单件模式是最简单的设计模式，它是允许一个类有且仅有一个实例的方法。创建一个单件模式的关键是防止客户程序员获得任何控制其对象生存期的权利。为了做到这一点，声明所有的构造函数为私有，并且防止编译器隐式生成任何构造函数。
命令模式是一个函数对象，通过将函数封装为对象，以参数形式将其传递给其他函数或对象，告诉它们在履行请求的过程中执行特定的操作。命令模式的主要特点是允许向一个函数或者对象传递一个想要的动作。
代理模式和状态模式都提供一个代理类。代码与代理类打交道，而做实际工作的类隐藏在代理类背后。当调用代理类中的一个函数时，代理类仅转而去调用实现类中相应的函数。代理模式分为远程代理、虚拟代理、保护代理和巧妙引用。状态模式产生一个可以改变其类的对象，当发现在大多数或者所有函数中都存在有条件的代码时，这种模式很有用。和代理模式一样，状态模式通过一个前端对象来使用后端实现对象履行其职责。然而，在前端对象生存期期间，状态模式从一个实现对象到另一个实现对象进行切换，以实现对于相同的函数调用产生不同的行为。
模板方法模式是应用程序结构框架中的一个基本的概念，隐藏在覆盖的下方，通过调用基类的不同函数来驱动程序运行。
策略模式按照“组合优于继承”的格言，可以利用组合来解决将变化的代码从“坚持相同的代码”中分开的问题。
职责链模式被看做一个使用策略对象的“递归的动态一般化”。
工厂模式是用于封装对象的创建，不允许将创建对象的代码散布于整个系统。
构造器模式用于创建复杂对象，将对象的创建和它的“表示法”分开，创建过程保持原状，产生对象的表示法可能不同。 