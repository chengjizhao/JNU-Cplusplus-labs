第十章
模式存在独立于特定实现方法，可以通过多种方式实现。
模式的基本概念被看作是程序设计的一般概念，即通过增加抽象层来隔离变化和不变。
创建型：用于怎样创建一个对象。通常包括隔离对象创建的细节，这样代码不依赖于对象是什么类型，因此在增加一种新的对象类型时不需要改变代码。如单件模式、工厂模式和构建器模式。
结构型：影响对象之间的连接方式，确保系统的变化不需要改变对象间的连接。结构型模式常常由工程项目限制条件来支配。如代理模式和适配器模式。
行为型：在程序中处理具有特定操作类型的对象。这些对象封装要执行的操作过程，比如解释一种语言、实践一个请求、遍历一个序列（如像在一个迭代器内）或者实现一个算法。如命令模式、模板方法模式、状态模式、策略模式、职责链模式、观察者模式、多派遣模式和访问者模式。
信使将消息封装到一个对象中到处传递，而不是将消息的所有片段分开进行传递。信使的目标只是为了携带数据，可将这些数据安排为公有成员以便访问。
收集参数的工作是从传递给它的函数中获取信息。通常，当收集参数被传递给多个函数的时候使用它。容器对于收集参数特别有用，因为它已经设置为动态增加对象。
单件是允许一个类有且仅有一个实例的方法。创建一个单件模式的关键是防止客户程序员获得任何控制其对象生存期的权利。
命令模式就是一个函数对象：一个作为对象的函数。通过将函数封装为对象，就能够以参数的形式将其传递给其他函数或者对象，告诉它们在履行请求的过程中执行特定的操作。可以说，命令模式是携带行为信息的信使。
命令模式的主要特点是允许向一个函数或者对象传递一个想要的动作。
代理类派生自一个基类，由平行地派生自同一个基类的一个或多个类提供实际的实现。当一个代理对象被创建的时候，一个实现对象就分配给了它，代理对象就将函数调用发给实现对象。
从结构上来看，代理模式和状态模式的区别很简单：代理模式只有一个实现类，而状态模式有多个（一个以上）实现。（在GoF中）认为这两种设计模式的应用也不同：代理模式控制对其实现类的访问，而状态模式动态地改变其实现类。
模板方法模式的一个重要特征是它的定义在基类中（有时作为一个私有成员函数）并且不能改动—模板方法模式就是“坚持相同的代码”。它调用其他基类函数（就是那些被覆盖的函数）以便完成其工作，但是客户程序员不必直接调用这些函数。
模板方法模式是“坚持相同的代码”，而被覆盖的函数是“变化的代码”。然而，这种变化在编译时通过继承被固定下来。按照“组合优于继承”，可以利用组合来解决将变化的代码从“坚持相同的代码”中分开的问题，从而产生策略（Strategy）模式。


