## 第11章

1. 运算符重载：其是一种形式的c++多态。例子：`operator+()重载+运算符`

2. 重载示例：`t4=t2.operater(t.operator+(t1))`后者返回一个Time对象，为t和t1的综合.然后返回t2+t1+t的总和。

   重载限制：重载运算符不必是成员函数，重载后的运算符必须至少有一个操作数是用户定义的类型。比如不能将减法运算符重载为两个数的和。使用运算符时不能违反运算符原来的语法规则。例如不能将%重载为一个操作数。同样的也不能修改运算符的优先级。

3. 友元：`a=b*2.75->a=b.operator->a=operator(2.75,b);`
   关键词：friend。 创造特殊的非成员函数，可以访问类的私有成员，称为友元函数。
   常用的友元函数

   ```C++
   //第一种重载方式：
   void operator <<(ostream & os,const time & t)
   {
       os << t.hours << "hours" << t.minutes << 'minutes";
   }
   //第二种重载方式：
   ostream & operator <<(ostream & os,const time & t)
   {
       os << t.hours << "hours" << t.minutes << 'minutes";
       return os;
   }
   ```

4. 对于大部分运算符来说，可以选择使用成员函数和非成员函数进行运算符的重载。要根据情况进行选择。

5. 矢量（具有大小和方向），为类重载运算符。可以写在构造函数内。

   ```C++
   vector vector::operator+(vector b)
   {
   }
   ```

6. 类的自动转换和强制类型转换
   `int *p=(int *) 10;`
   自动转换:自动转换指的是当表达式中包含不同类型的类对象时，编译器会自动将其中一个对象的类型转换为另一个对象的类型。这种转换是隐式进行的，无需进行任何显式的类型转换。常见的自动转换方式有：从派生类转换为基类.

   强制类型转换:当需要进行类型转换时，可以使用强制类型转换。这种转换需要通过显式的强制类型转换语法来实现，可以将任意类型的对象转换为另一个类型。

   C++ 提供了四种强制类型转换方式：static_cast：用于进行用于非多态类型的转换，在编译时检查类型安全。dynamic_cast：用于进行运行时多态类型的转换，会进行类型检查，如果转换失败则返回空指针。const_cast：用于去除 const 和 volatile 限定符。reinterpret_cast：用于进行底层的强制类型转换，可能会导致未定义行为。使用强制类型转换时需要非常小心，不当的类型转换可能会导致程序出现不可预期的行为，而且强制类型转换也可能会破坏代码的类型安全性。在进行强制类型转换时，需要尽可能地保证转换的正确性，并检查转换后的分配对象是否满足要求。

   转换函数和友元函数:在 C++ 中，我们还可以通过友元函数来实现类的类型转换。具体来说，如果我们希望让某个非类类型通过调用类的成员函数来进行转换，但是又不希望将转换函数作为类的成员函数来定义，那么可以定义一个友元函数来实现这个功能。

## 第12章

1. 动态内存和类：动态内存分配指的是在程序运行的过程中，根据需要动态地分配内存空间。与之相对应的是静态内存分配，即在程序编译时就就已经确定了内存的分配情况，无法根据程序运行的需要进行调整。动态内存分配的过程需要使用到两个运算符：new 和 delete。其中，new 运算符用于向操作系统申请内存空间，返回指向该空间的指针；delete 运算符用于释放之前申请的动态内存空间，使该空间变为可用状态。
   特殊成员函数：分别为默认构造函数、析构函数、拷贝构造函数、移动构造函数、拷贝赋值运算符和移动赋值运算符。
   默认构造函数是不带参数的构造函数，如果没有手动实现构造函数，编译器会默认生成一个默认构造函数。它主要用于在创建对象时进行对象的初始化。如果类中有其他的构造函数，则需要显示地定义并实现默认构造函数，否则编译器不会生成默认构造函数。
   析构函数与构造函数相对应，用于在对象生命周期结束时执行清理操作。它的函数名为 ~类名()，并且没有参数和返回值。如果类中没有手动实现析构函数，则编译器会默认生成一个析构函数。
   拷贝构造函数用于创建一个新对象，并使用另一个同类型的已有对象进行初始化。它的形式为 类名(const 类名& other)，它必须是 const 引用。如果类中没有手动实现拷贝构造函数，则编译器会默认生成一个拷贝构造函数。移动构造函数与拷贝构造函数类似，也是用于创建一个新对象，但它使用右值引用参数（如 类名(类名&& other)）来接收对象，并在创建新对象时“窃取”已有对象的资源而不复制。移动构造函数常见于实现高效的“移动语义”。
   拷贝赋值运算符与拷贝构造函数相似，但它是在已有对象的内容被覆盖或重新使用时使用的。它的形式为 类名& operator=(const 类名& other)，返回一个类的引用。如果类中没有手动实现拷贝赋值运算符，则编译器会默认生成一个拷贝赋值运算符。
   移动赋值运算符与拷贝赋值运算符类似，但它使用右值引用参数（如 类名& operator=(类名&& other)）来接收对象，并在重新使用已有对象时“窃取”已有对象的资源而不进行复制操作。移动赋值运算符也常见于实现高效的“移动语义”。
   需要注意的是，如果类中定义了任何一种特殊成员函数，则在需要调用其它特殊成员函数时，也需要将其进行显式的定义和实现。这是因为编译器只会在需要时自动生成缺失的特殊成员函数，而如果特殊成员函数不是默认形式的（比如带有参数或调用了其它函数），则编译器无法自动为其生成默认实现。

2. 改进后的新string类：
   比较成员函数：可以重载<来比较string函数的字符大小。或者使用std::strcmp来进行比较。
   使用括号法表示访问字符：string a（"sadasd"）;
   静态类成员函数：用static声明，静态类成员函数是不依赖于类的实例而存在的函数。它们与类的作用域相关，但是不需要类的实例来调用。静态类成员函数可以访问类的静态成员变量和其他静态类成员函数，不能访问类的非静态成员变量和非静态成员函数。

3. 构造中使用new的注意事项，delete释放内存，其他等等。

4. 返回对象的指针。