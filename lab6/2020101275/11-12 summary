第11章 使用类
C++中对于重载运算符有如下的限制：
（1）重载后的运算符必须至少有一个操作数是用户自定义的类型，这能够防止用户为标准类型重载运算符；
（2）使用运算符时不能违反运算符原有的句法规则，例如，不能将求模运算符（%）重载成只使用一个操作数，也不能修改运算符的优先级；
（3）不能创建新运算符，例如，不能定义operator**()表示求幂。
（4）不能重载的运算符：
sizeof运算符
. 成员运算符
.* 成员指针运算符
:: 作用域解析运算符
?: 条件运算符
typeid  一个RTTI运算符
const_cast 强制类型转换运算符
dynamic_cast 强制类型转换运算符
reinterpret_cast 强制类型转换运算符
static_cast 强制类型转换运算符
（5）大多数运算符都可以通过成员或非成员函数进行重载，但下面的运算符只能通过成员函数进行重载
= 赋值运算符
()函数调用运算符
[]下标运算符
->通过指针访问类成员的运算符。
11.3.友元
友元是访问类对象私有部分的另一种形式。友元函数、友元类、友元成员函数。常规非成员函数不能直接访问类的私有数据，必须使用友元函数。
创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字friend；第二步编写函数定义。不要在定义中使用关键字 friend。

第12章 类和动态内存分配

（1）特殊成员函数
如果没有定义，C++会自动提供下面这些成员函数：
默认构造函数
默认析构函数
复制构造函数
赋值运算符
地址运算符
（2）静态类成员函数
可以将类成员函数声明为静态的，函数声明必须包含关键字static，但如果函数定义是独立的，则不能包含关键字static。
不能通过对象调用静态成员函数如果静态成员函数是在共有部分声明的，则可以使用类名和作用域解析运算符来调用它。
由于静态成员函数不与特定的对象相关联，因此只能使用静态数据成员。
（3）在构造函数中使用new的方法
构造函数中使用new来初始化指针成员，在析构函数中使用delete。
new和delete必须相互兼容。new应对应于delete，new[]应对应于delete[]。
如果有多个构造函数，则必须以相同的方式使用new，要么都带中括号，要么都不带。因为只有一个析构函数，所有的构造函数都必须与它兼容。然而，可以在一个构造函数中使用new初始化指针，而在另一个构造函数中将指针初始化为空（0或C++11中的nullptr），这是因为delete（无论是否带中括号）可以用于空指针。
