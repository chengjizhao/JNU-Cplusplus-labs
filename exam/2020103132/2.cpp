/*什么是纯虚函数和抽象类？它们如何与虚函数表和虚指针相关联？
通过一个包含纯虚函数的抽象类示例，说明它的虚函数表和虚指针的情况。
为什么包含纯虚函数的类不能实例化？请提供解释。*/
#include<iostream>

/*纯虚函数和抽象类：
在C++中，一个纯虚函数是一个在基类中声明的虚函数，但没有为其提供定义。
抽象类是一个包含至少一个纯虚函数的类。
纯虚函数允许我们定义一个接口，但不指定实现。
子类可以选择是否实现这个纯虚函数，从而实现该接口。
如果一个类继承自一个包含纯虚函数的抽象类，那么这个类必须实现所有的纯虚函数，
除非它也是一个抽象类。*/

/*虚函数表和虚指针：
每个包含虚函数的类都有一个虚函数表（也称为vtable）。
这是一个特殊的表，其中包含指向虚函数的指针。
每个对象都有一个指向其类vtable的虚指针（vptr）。
当对象被创建时，vptr被初始化为指向相应的vtable的指针。
当通过基类指针或引用调用虚函数时，编译器通过查找vtable来确定实际调用的函数。*/

//示例：包含纯虚函数的抽象类
class A 
{  
public:  
    virtual void func() 
    { 
        std::cout << "A::func" << std::endl; 
    }  
};

class B:public A
{  
public:  
    void func()override 
    { 
        std::cout<<"B::func"<<std::endl; 
    }  
};

int main() 
{  
    B bObject;  
    A*basePtr = &bObject;  
    basePtr->func();  
    return 0;  
}
/*对于上面的A，编译器会为其生成一个vtable，该vtable中包含一个
指向func()的指针。同时，每个A的对象都会有一个vptr，指向这个vtable。
但是，由于func()没有定义，所以这个vtable中没有实际的函数地址。
当尝试实例化A时，会导致编译错误，因为其是一个抽象类且不能被实例化。
由于包含纯虚函数的类是抽象的，表示它定义了一个接口但并没有实现。
如果我们能够实例化这样的类，那么我们实际上是在创建一个对象，
但这个对象的行为是不确定的（因为它可能试图调用一个未定义的函数）。
所以，不允许对这样的类进行实例化是一种防止错误的机制。*/