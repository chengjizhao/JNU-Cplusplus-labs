/*虚函数表的概念：虚函数表是一种用于实现多态的机制，它是一个存储了类的虚函数地址的静态数组，每个包含虚函数的类都有一个自己的虚函数表。编译器会在类中添加一个隐藏的指针，称为虚函数指针，它指向类的虚函数表。当一个类被实例化时，虚函数指针就被初始化为指向该类的虚函数表。*/
/*编译器如何生成虚函数表：编译器会根据类的定义和继承关系，为每个包含虚函数的类生成一个虚函数表，并将虚函数的地址按照一定的顺序存放在虚函数表中。编译器还会为每个类生成一个构造函数，用于初始化虚函数指针。*/
/*如何修改一个类并访问虚函数表：为了证明虚函数表的存在，可以通过强制类型转换的方式，将类的对象地址转换为指向虚函数表的指针，然后通过该指针访问虚函数表中的内容。例如，假设有一个类A，它有两个虚函数f1和f2，代码如下：*/
class A {
public:
    virtual void f1() { cout << "A::f1" << endl; }
    virtual void f2() { cout << "A::f2" << endl; }
};

// 定义一个函数指针类型
typedef void (*func)();

int main() {
    A a; // 创建一个A类的对象
    func* vtable = (func*)(&a); // 将对象地址转换为指向虚函数表的指针
    cout << "vtable address: " << vtable << endl; // 输出虚函数表的地址
    cout << "f1 address: " << vtable[0] << endl; // 输出f1函数的地址
    cout << "f2 address: " << vtable[1] << endl; // 输出f2函数的地址
    vtable0; // 通过虚函数表调用f1函数
    vtable1; // 通过虚函数表调用f2函数
    return 0;
}
/*虚函数表在继承中的工作方式：当一个类继承自另一个类时，它会继承基类的虚函数表，并根据自己的定义进行修改。如果派生类重写了基类的虚函数，那么它会在虚函数表中替换掉基类的虚函数地址；如果派生类没有重写基类的虚函数，那么它会保留基类的虚函数地址；如果派生类添加了自己的虚函数，那么它会在虚函数表的尾部追加自己的虚函数地址。*/
