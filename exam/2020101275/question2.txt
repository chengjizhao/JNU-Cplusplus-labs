1.什么是纯虚函数和抽象类？
抽象类是包含至少一个纯虚函数的类，无法被实例化，可以提供一个接口并强制派生类实现该接口。纯虚函数在抽象类中声明但不提供实现的虚函数，在声明的结尾添加 `= 0` 进行说明。

2.纯虚函数和抽象类如何与虚函数表和虚指针相关联？
通过一个包含纯虚函数的抽象类示例，说明它的虚函数表和虚指针的情况。
每个含有虚函数的类都有一个虚函数表。对于抽象类，如果它包含至少一个纯虚函数，那么它也将有一个虚函数表。虚函数表是一个存储虚函数地址的表格，使得在运行时能够动态地调用适当的虚函数。对于每个具体的类，虚函数表中的条目是该类的虚函数的地址。抽象类的虚函数表中会包含所有纯虚函数的地址，因为派生类需要实现这些函数。
虚指针是对象的内存布局中通常包含一个指向虚函数表的指针。这个指针位于对象的起始位置（或者在某些实现中位于对象的末尾），通过这个指针可以找到对象所属类的虚函数表。当调用一个虚函数时，编译器通过虚指针找到对象所属的虚函数表，然后在表中查找对应函数的地址进行调用。
示例：
class Shape {
public:
    virtual void draw() const = 0; 
};

class Circle : public Shape {
public:
    void draw() const override {
    }
};

int main() {
    Circle c;
    c.draw(); 
    return 0;
}
示例中，Shape 类是抽象类，包含一个纯虚函数 draw。Circle 类是 Shape 的派生类，实现了 draw 函数。在 main 函数中，创建了一个 Circle 对象，通过虚指针和虚函数表调用了实际的 draw 函数。虚指针是在运行时被动态设置的，确保调用的是正确的派生类实现。

3.为什么包含纯虚函数的类不能实例化？请提供解释。
包含纯虚函数的类不能实例化的主要原因是这些类没有提供纯虚函数的具体实现，因此在实例化时无法确定如何执行这些函数。
以下是导致包含纯虚函数的类不能实例化的几个关键原因：
未定义的行为： 类中的纯虚函数没有提供默认实现，因此创建对象时没有定义的行为。在 C++ 中，对象的构造需要知道所有成员的实现，而包含纯虚函数的类无法提供这些实现。
缺少必要的信息： 纯虚函数只有声明，没有实际的函数体。因此，编译器无法为这些函数生成具体的代码，也无法在对象中为这些函数分配存储空间。
不完整的类型： 包含纯虚函数的类被称为抽象类，它是一个不完整的类型。不完整的类型不能被实例化，因为编译器无法确定对象的大小和结构。

示例：
class Abstract {
public:
    virtual void pureVirtualFunction() = 0;  // 纯虚函数
};

int main() {
    // 以下代码无法编译，因为 Abstract 是抽象类
    // Abstract obj;  // 错误：无法创建抽象类的实例

    return 0;
}
示例中，Abstract 包含一个纯虚函数，因此它是抽象类，无法被实例化。要创建抽象类的实例，必须先派生一个具体的子类，并提供纯虚函数的具体实现。抽象类的实例化是通过派生类完成的，确保所有的纯虚函数都有具体的实现。