第11章
1.运算符重载
操作符重载（Operator Overloading）是一种形式的C++多态。

1.1 概述
函数重载（函数多态）：定义多个名称相同但特征标（参数列表）不同的函数。
函数重载（function overloading）、函数多态（function polymorphism）。

C++允许将运算符重载扩展到用户定义的类型。要重载运算符，需使用被称为运算符函数的特殊函数形式。运算符函数的格式如下：

// op表示要重载的操作符符号，如 operator +()
operator op(argument-list)

// 如：operator []() 数组索引运算符

op必须是有效的C++运算符，不能虚构一个新的操作符号。
不要返回指向局部变量或临时对象的引用。函数执行完毕之后，局部变量和临时对象将消失，引用将指向不存在的数据。

1.2 重载限制
重载后的运算符必须至少有一个是用户定义的类型。目的：防止用户对标准类型重载运算符。
使用运算符时，不能违反运算符原来的句法规则。不能改变优先级。
不能创建新运算符。如： operator **() 函数表示求幂（不允许）

不能重载下面的运算符
sizeof运算符
成员运算符（.）
成员指针运算符（.*）
作用域解析运算符（::）
条件运算符（:?）
一个RTTI运算符（typeid）
强制类型转换运算符（const_cast、dynamic_cast、reinterpret_cast、static_cast）。

只能通过成员函数重载的操作符
赋值运算符（=）
函数调用运算符（()）
下标运算符（[]）
通过指针访问类成员的运算符（->）

2. 友元简介
C++提供另外一种形式的访问权限：友元。友元有3种：
友元函数
友元类
友元成员函数

通过让函数成为类的友元，可以赋予该函数与类的成员函数系统的访问权限。
在为类重载二元运算符时（带两个参数的运算符）常常需要友元。
对于非成员重载运算符函数来说，运算符表达式左边的操作数对应于运算符函数的的第一个参数，运算符表达式右边的操作数对应于运算符函数的第二个参数，而原来的成员函数则按相反的顺序处理操作数。
通过友元函数，可以让非成员函数也可与类成员函数相同的访问权限。

2.1 创建友元
创建原型
创建友元函数，将其原型放在类声明中，并在原型声明前加上关键字 friend：

friend Time operator * (double m,const Time & t)
/** operator*() 函数是在类声明中声明的，但不是成员函数，因此不能使用成员运算符来调用
 * operator*() 函数不是成员函数，但它与成员函数的访问权限相同
 */

编写函数定义 因不是成员函数，所以不需要使用 Time:: 限定符。不要在定义中使用关键字 friend。

Time operator*(double m, const Time & t) // 友元不用在函数定义中使用
{
    Time result;
    long totalminutes = t.hours * mult * 60 + t.minutes * mult;
    result.hours = totalminutes / 60;
    result.minutes = totalminutes % 60;
    return result;
}

2.2 常用的友元：重载 << 运算符
<<运算符是C和C++的位运算符，将值中的位左移。ostream类对该运算符进行重载，将其转换为一个输出工具。
ostream类声明中都包含相应的重载的 operator<<()定义。

ostream & operator <<(ostream & os, const c_name & obj)
{
    os << ...; // 显示内容
    return os;
}

只有在类声明中的原型才能使用 friend 关键字。除非函数定义也是原型，否则不能在函数定义中使用该关键字。

3. 重载运算符：作为成员函数还是非成员函数
对于很多运算符来说，可选择使用成员函数或非成员函数来实现运算符重载。而非成员函数则必须是友元函数才能访问类的私有数据。

// ---------------- Time 类 --- 注意：加法属于二元操作符（需要两个操作数）-----
Time operator+(const Time & t) const; //成员函数版本（一个操作数通过this指针隐式磁道没，而另一个则是作为函数参数显式传递）

friend Time operator+(const Time & t1,const Time & t2);// 非成员函数版本（友元函数，两个操作数都是作为参数传递）

非成员版本的重载运算符函数所需的形参数目与运算符使用的操作数数目相同；而成员函数所需的参数数目少一个，因为其中的一个操作数是被隐式地传递的调用对象。

T1 = T2 + T3;
T1 = T2.operator+(T3); // 成员函数格式
T1 = operator+(T2,T3); //非成员函数格式

在定义运算符是，必须选择其一，而不能同时选择两种格式，否则会出现二义性，从而导致编译错误。

4. 重载示例：矢量类
使用运算符重载和友元的类设计 ----- 一个表示矢量的类。
矢量（vector）是工程和物理中使用的一个术语，是有大小和方向的量。

5. 类的自动转换和强制类型转换
将一个标准类型变量的值赋给另一种标准类型的变量时，如果两种类型兼容，则C++自动将该值转换为接收变量的类型。但是也会伴随精度丢失的情况发生。

5.1 两种类型转换
在无法完成自动转换时，可以使用强制类型转换。

隐式转换

//使用构造函数创建一个临时对象并初始化，然后采用逐成员赋值的方式将临时对象的内容复制到myCat中，这种方式称为隐式转换。
Stonewt(double lbs);
Stonewt myCat;
myCat = 19.6;
// 只有接受一个参数的构造函数才能作为转换函数

隐式转换是自动进行，而不需要显式强制类型转换。

显式转换

将构造函数用于自动类型转换会出现意外情况，所以C++新特性使用 关键字 explicit 来关闭自动特性。

// 声明构造函数的格式
explicit Stonewt(double lbs); //不隐式转换（显式转换）
只接受一个参数的构造函数定义了从参数类型到类类型的转换。如果在声明中使用关键字 explicit，则只用于显式强制类型转换。否则会用于如下的隐式转换。（避免存在二义性）

将Stonewt对象初始化为doubel值时
将double值赋给Stonewt对象时。
将double值传递给接受Stonewt参数的函数时。
上述任一情况下，使用可转换为double类型的内置类型时。

5.2 转换函数
C++运算符函数 ----- 转换函数：用户自定义的强制类型转换，可进行类似使用内置强制类型转换一样的方式。

operator typeName(); // typeName指要转换成的类型
operator double(); //转换为double类型的函数原型

转换函数的注意点：
必须是类方法：需要通过类对象来调用，从而告知函数要转换的值。
不能指定返回类型
不能有参数

转换函数没有返回类型、没有参数、但必须返回转换后的值（虽然没有声明返回值的类型）

C++为类提供的类型转换
只有一个参数的类构造函数用于将类型与该参数相同的值转换为类类型。在构造函数声明中使用 explicit可防止隐式转换，而只允许显式转换。
被称为转换函数的特殊类成员运算符函数，用于将类对象转换为其他类型。


第12章
1. 动态内存和类
C++中使用 new 和 delete 运算符来动态控制内存，析构函数不可缺少，否则会导致很多新的编程问题的出现。有时必须重载赋值运算符，从而保证程序正常运行。

1.1 静态类成员
静态类成员的特点：无论创建多少个对象，程序都只创建一个静态类变量副本（类的所有对象共享同一个静态成员）。
不能在类声明中初始化静态成员变量（声明描述了如何分配内存，但不分配内存）。可以在类声明之外单独使用单独语句来进行初始化（静态成员变量是单独存储，而不属于对象的组成部分）。
注意：静态数据成员在类声明中声明，在包含类方法的文件中的初始化。初始化时使用作用域运算符来指出静态成员所属的类。但如果静态成员是整型或枚举型const，则可以在类声明中初始化。
在构造函数中使用new来分配内存时，必须在相应的析构函数中使用delete来释放内存。如果使用 new[] （包括中括号）来分配内存，则应使用delete[]（包括中括号）来释放内存。
自动存储对象被删除的顺序与创建顺序相反。

静态成员函数的声明中必须包含关键字 static，但如果函数定义是独立的，则其中不能包含关键字static。原因有二：
不能通过对象调用静态成员函数，甚至不能使用this指针。
静态成员函数不与特定的对象相关联，只能使用静态数据成员。

1.2 特殊成员函数
C++提供的隐式成员函数：
默认构造函数，如果没有定义构造函数
如果没有提供任何构造函数，C++将创建默认构造函数。

StringBad::StringBad() {} // 隐式默认构造函数

编译器将提供一个不接受任何参数、也不执行如何操作的构造函数（默认的默认构造函数）。
默认析构函数，如果没有定义
复制构造函数，如果没有定义

定义
复制构造函数用于将一个对象复制到新创建的对象中。用于初始化过程中（包括按值传递），而不是常规的赋值过程。类的复制构造函数的原型如下：

Class_name(const Class_name &); //接收一个指向对象的常量引用作为参数

何时调用？
每当程序生成对象副本时，编译器都会使用复制构造函数。常见的情况：
当函数按值传递对象时
当函数返回对象时
当编译器生成临时对象时

默认的复制构造函数的功能
默认的复制构造函数逐个复制非静态成员（成员复制，也称为浅拷贝），复制的是成员的值。

如果类中包含了使用new初始化的指针成员，应当定义一个拷贝构造函数，以复制指向的数据，而不是指针。这种称为深拷贝。浅拷贝只拷贝指针值（拷贝指针信息）

赋值运算符，如果没有定义
定义和原型函数
C++允许类对象赋值，通过自动为类重载复制运算符来实现。函数原型如下：

Class_name & Class_name::operator=(const Class_name &);

赋值运算符的作用
解决默认赋值运算符不合适导致的问题。

实现复制运算符（进行深拷贝）的注意点：
目标对象可能引用以前分配的数据，所以函数应使用 delete[] 来释放数据。
函数应当避免将对象赋值给自身：否则给对象重新赋值时，释放内存操作可能删除对象的内存。
函数返回一个指向调用对象的引用。

地址运算符，如果没有定义
当使用一个对象来初始化另一个对象时，编译器将自动生成复制构造函数（创建对象的一个副本）。例如：

StringBad(const StringBad &)

2. 在构造函数中使用new时的注意事项
使用new初始化对象的指针成员时必须小心。具体做法如下：
如果在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete。
new 和 delete必须相互兼容。new对应于delete，new[] 对应于 delete[]
如果有多个构造函数，则必须以相同的方式使用 new，要么带括号，要么都不带。
定义一个拷贝构造函数，通过深拷贝将一个对象初始化为另一个对象。

3. 返回对象的问题
当成员函数或独立的函数返回对象时，有3种返回方式
指向对象的引用
指向对象的const引用
const对象

4. 使用指向对象的指针
使用对象指针时的注意事项
使用常规表示法来声明指向对象的指针。
将指针初始化为指向已有的对象。
可使用 new 来初始化指针，创建一个新的对象。
对类使用 new 将调用相应的类构造函数来初始化新创建的对象。
可使用 -> 运算符通过指针访问类方法。
可对对象指针应用解除引用运算符来获得对象。