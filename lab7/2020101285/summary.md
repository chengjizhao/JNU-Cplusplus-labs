## 第11章总结
- 重载运算符：可以通过在类中对成员函数使用 `operator+` "运算符" 代替函数名，使原本只能用于变量的运算符也适用于对象。
- 重载运算符的目的是不改变原有运算符的功能，而是通过定义适当的重载函数来实现针对类的操作。
- 重载运算符不能创造新的运算符，而是给已有的运算符添加了针对类的操作。

### 友元函数与友元类
- 友元函数：可以访问类的私有、保护成员，而不是类的成员函数。在类中使用 `friend` 关键字声明友元函数。
- 友元类：可以在一个类中声明另一个类作为友元类，从而使得被声明的友元类可以共享自己的私有成员。
- 友元关系不能传递，也是不可逆的。

### 特定运算符的重载
- `<<` 运算符：通常被用作输出工具，在类中重载该运算符可以自定义对象的输出格式。

### 类的自动转换与强制类型转换
- 类的自动转换：将某一类型的对象隐式转换为其他类型的对象，需定义类型转换函数。
- 强制类型转换：通过使用特定的转换运算符或者强制转换操作符来将一个类型强制转换为另一个类型。

---

## 第12章总结
- 静态成员变量与动态内存分配：
  - 不能在类声明中初始化静态成员变量，因为声明只描述如何分配内存，不分配内存。
  - 静态成员变量不属于对象内部，因此 `this` 指针无法指向静态成员变量。
  - 在存储字符串时，由于无法确定所需分配的空间大小，需要使用动态内存分配，使用 `new()` 进行内存分配，使用 `delete()` 进行释放。
  - 默认的复制构造函数会导致浅拷贝问题，即多个对象共享同一块内存，会导致错误。因此，需要实现深拷贝，在构造函数中使用 `new()` 分配内存，在析构函数中释放内存。
  - 深拷贝的实现还需要注意重载赋值运算符 `=`，确保在赋值操作中也进行适当的内存分配和内容拷贝。