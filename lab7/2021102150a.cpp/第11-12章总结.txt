11章 使用类

运算符重载。
友元函数。
重载<<运算符，以便用于输出。
状态成员。
使用rand( )生成随机值。
类的自动转换和强制类型转换。
类转换函数。

11.1运算符重载
运算符重载是一种形式的C++多态。用户能够定义多个名称相同但特征标（参数列表）不同的函数，这被称为函数重载或函数多态，旨在让用户能够用同名的函数来完成相同的基本操作，即使这种操作被用于不同的数据类型。C++允许将运算符重载扩展到用户定义的类型，例如，允许使用+将两个对象相加。编译器将根据操作数的数目和类型决定使用哪种加法定义。重载运算符可使代码看起来更自然。

11.2 计算时间
本章节举了计算时间的例子，要计算小时与分钟的混合，即相加单位类型不匹配。本小结中采用一个使用方法来处理加法的类。该类Time中提供了用于调整和重新设置时间、显示时间、将两个时间相加的方法。在AddMin中，使用%来计算进位。

使用operator可以对符号进行重载
重载的运算符（有些例外情况）不必是成员函数，但必须至少有一个操作数是用户定义的类型。
重载限制：
1、重载后的运算符必须至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符。因此，不能将减法运算符（−）重载为计算两个double值的和，而不是它们的差。
2、使用运算符时不能违反运算符原来的句法规则。不能修改运算符的优先级。
3、不能创建新运算符

11.3 友元
C++控制对类对象私有部分的访问。公有类方法提供唯一的访问途径，但是有时候这种限制太严格，以致于不适合特定的编程问题。在这种情况下，C++提供了另外一种形式的访问权限：友元。友元有3种：
1、友元函数 2、友元类 3、友元成员函数。
通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。在为类重载二元运算符时（带两个参数的运算符）常常需要友元。有一类特殊的非成员函数可以访问类的私有成员，它们被称为友元函数。

创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字friend。第二步是编写函数定义。因为它不是成员函数，所以不要使用Time::限定符。另外，不要在定义中使用关键字friend。

总结:类的友元函数是非成员函数，其访问权限与成员函数相同。

重载<<运算符
可以使其能与cout一起来显示对象的内容

11.4 重载运算符：作为成员函数还是非成员函数
对于很多运算符来说，可以选择使用成员函数或非成员函数来实现运算符重载。一般来说，非成员函数应是友元函数，这样它才能直接访问类的私有数据。

11.5 再谈重载：一个矢量类
矢量包含大小与方向，应该用一个类来表示。矢量的计算与普通数学运算有相似之处，可以重载运算符，使之能用于矢量。

11.6类的自动转换和强制类型转换
将一个标准类型变量的值赋给另一种标准类型的变量时，如果这两种类型兼容，则C++自动将这个值转换为接收变量的类型。可以将类定义成与基本类型或另一个类相关，使得从一种类型转换为另一种类型是有意义的。在这种情况下，程序员可以指示C++如何自动进行转换，或通过强制类型转换来完成。

11.7 总结
一般来说，访问私有类成员的唯一方法是使用类方法。C++使用友元函数来避开这种限制。要让函数成为友元，需要在类声明中声明该函数，并在声明前加上关键字friend。
C++扩展了对运算符的重载，允许自定义特殊的运算符函数，这种函数描述了特定的运算符与类之间的关系。运算符函数可以是类成员函数，也可以是友元函数（有一些运算符函数只能是类成员函数）。要调用运算符函数，可以直接调用该函数，也可以以通常的句法使用被重载的运算符。
C++允许指定在类和基本类型之间进行转换的方式。首先，任何接
受唯一一个参数的构造函数都可被用作转换函数，将类型与该参数相同
的值转换为类。如果将类型与该参数相同的值赋给对象，则C++将自动
调用该构造函数。
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

第十二章 类和动态内存分配

对类成员使用动态内存分配。
隐式和显式复制构造函数。
隐式和显式重载赋值运算符。
在构造函数中使用new所必须完成的工作。
使用静态类成员。
将定位new运算符用于对象。
使用指向对象的指针。
实现队列抽象数据类型（ADT）。

介绍如何对类使用new和delete以及如何处理由于使用动态内存而引起的一些微妙的问题。

12.1 动态内存和类

C++在分配内存时采取的策略是，在程序运行时在决定内存分配，而不是在编译时决定。这样，可根据程序的需要，而不是根据一系列严格的存储类型规则来使用内存。C++使用new和delete运算符来动态控制内存。但是在类中使用这些运算符将导致许多新的问题，在这种情况下使用析构函数将是必不可少的。

在stringbad类中出现错误
1、静态成员的初始化：由于静态内存是单独储存的，而不是对象的组成部分。初始化是在方法文件中，而不是在类声明文件中进行的，这是因为类声明位于头文件中，程序可能将头文件包括在其他几个文件中。如果在头文件中进行初始化，将出现多个初始化语句副本，从而引发错误。
2、该析构函数首先指出自己何时被调用。这部分包含了丰富的信息，但并不是必不可少的。然而，delete语句却是至关重要的。str成员指向new分配的内存。当StringBad对象过期时，str指针也将过期。但str指向的内存仍被分配，除非使用delete将其释放。删除对象可以释放对象本身占用的内存，但并不能自动释放属于对象成员的指针指向的内存。因此，必须使用析构函数。在析构函数中使用delete语句可确保对象过期时，由构造函数使用new分配的内存被释放。

StringBad类的问题是由特殊成员函数引起的。StringBad类中的问题是由隐式复制构造函数和隐式赋值运算符引起的。

默认构造函数，如果没有定义构造函数；
默认析构函数，如果没有定义；
复制构造函数，如果没有定义；
赋值运算符，如果没有定义；
地址运算符，如果没有定义。

程序的输出表明，析构函数的调用次数比构造函数的调用次数多2，原因可能是程序确实使用默认的复制构造函数另外创建了两个对象。当callme2()被调用时，复制构造函数被用来初始化callme2()的形参，还被用来将对象sailor初始化为对象sports。默认的复制构造函数不说明其行为，因此它不指出创建过程，也不增加计数器num_strings的值。但析构函数更新了计数，并且在任何对象过期时都将被调用，而不管对象是如何被创建的。这是一个问题，因为这意味着程序无法准确地记录对象计数。

12.2 改进后的string类
在string中加入新功能

修改后的构造函数与析构函数兼容
将比较函数作为友元，有助于将string类与常规的C字符串进行比较
通过重载中括号运算符，可以使之与string类兼容
静态成员函数：可以将成员函数声明为静态的（函数声明必须包含关键字static，但
如果函数定义是独立的，则其中不能包含关键字static）

12.3 在构造函数中使用new时应注意的事项
如果在构造函数中使用new来初始化指针成员，则应在析构函数中
使用delete。
new和delete必须相互兼容。new对应于delete，new[ ]对应于delete[]。如果有多个构造函数，则必须以相同的方式使用new，要么都带中括号，要么都不带。因为只有一个析构函数，所有的构造函数都必须与它兼容。然而，可以在一个构造函数中使用new初始化指针，而在另一个构造函数中将指针初始化为空（0或C++11中的nullptr），这是因为delete（无论是带中括号还是不带中括号）可以用于空指针。
应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象。

12.4 有关返回对象的说明
当成员函数或独立的函数返回对象时，有几种返回方式可供选择。可以返回指向对象的引用、指向对象的const引用或const对象。使用const引用的常见原因是旨在提高效率。
如果被返回的对象是被调用函数中的局部变量，则不应按引用方式返回它，因为在被调用函数执行完毕时，局部对象将调用其析构函数。因此，当控制权回到调用函数时，引用指向的对象将不再存在。在这种情况下，应返回对象而不是引用。

12.5 使用指向对象的指针
C++程序经常使用指向对象的指针，比如使用数组索引值来跟踪最短的字符串和按字母顺序排在最前面的字符串。另一种方法是使用指针指向这些类别的开始位置

使用对象指针时，需要注意几点：
使用常规表示法来声明指向对象的指针：
可以将指针初始化为指向已有的对象：
可以使用new来初始化指针，这将创建一个新的对象
对类使用new将调用相应的类构造函数来初始化新创建的对象：

定位new运算符让您能够在分配内存时能够指定内存位置。该程序使用new运算符创建了一个512字节的内存缓冲区，然后使用
new运算符在堆中创建两个JustTesting对象，并试图使用定位new运算符
在内存缓冲区中创建两个JustTesting对象。最后，它使用delete来释放使
用new分配的内存。

12.6 复习各种技术
重载<<运算符，以便将他和cout一起用来显示对象的内容。
转换函数：将类转换成其他类型
构造函数使用new的类：
对于指向的内存是由new分配的所有类成员，都应在类的析构函数中对其使用delete，该运算符将释放分配的内存。
如果析构函数通过对指针类成员使用delete来释放内存，则每个构造函数都应当使用new来初始化指针，或将它设置为空指针。
构造函数中要么使用new []，要么使用new，而不能混用。如果构造函数使用的是new[]，则析构函数应使用delete []；如果构造函数使用的是new，则析构函数应使用delete。
应定义一个分配内存（而不是将指针指向已有内存）的复制构造函数。这样程序将能够将类对象初始化为另一个类对象。

12.7 队列模型Queue类

12.8 总结
在类构造函数中，可以使用new为数据分配内存，然后将内存地址赋给类成员。这样，类便可以处理长度不同的字符串，而不用在类设计时提前固定数组的长度。
如果对象包含指向new分配的内存的指针成员，则将一个对象初始化为另一个对象，或将一个对象赋给另一个对象时，也会出现问题。
对象的存储持续性为自动或外部时，在它不再存在时将自动调用其析构函数。
C++为类构造函数提供了一种可用来初始化数据成员的特殊语法。这种语法包括冒号和由逗号分隔的初始化列表，被放在构造函数参数的右括号后，函数体的左括号之前。
