第十一章 使用类
  函数重载：使用户能够定义多个名称相同但特征标（参数列表）不同的函数，旨在让用户能够用同名的函数来完成相同的基本操作。
  运算符重载：与函数重载类似，允许赋予C++运算符多种含义。
  很多C++运算符已经被重载。例如：运算符*用于地址，将得到存储在该地址中的值；而*用于两个数字时，得到的是两者的乘积。
  运算符函数格式：operatorop(argument - list)。例如：operator +( )表示重载+运算符； operator *( )表示重载*运算符。op必须是有效的C++运算符，不能虚构一个新的符号。但不能有operator@( )这样的函数， 因为C++中没有@运算符。
  C++对用户定义的运算符重载的限制：
  1、重载后的运算符必须至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符。因此，不能将减法运算符（-） 重载为计算两个double值的和， 而不是它们的差。虽然这种限制将对创造性有所影响， 但可以确保程序正常运行。
  2、使用运算符时不能违反运算符原来的句法规则。例如，不能将求模运算符（%）重载成使用一个操作数的运算符。
  3、不能修改运算符的优先级。因此，如果将加号运算符重载成将两个类相加，则新的运算符与原来的加号具有相同的优先级。
  4、不能创建新运算符。例如，不能定义operator **( )函数来表示求幂。
  5、不能重载的运算符： sizeof（sizeof运算符）、.（成员运算符）、. *（成员指针运算符）、::（作用域解析运算符）、?:（条件运算符）、typeid（一个RTTI运算符）和一些强制类型转换运算符。
  6、只能通过成员函数进行重载的运算符：=、（）、[]、->。
  C++控制对类对象私有部分的访问。通常，公有类方法提供唯一的访问途径，但是有时候这种限制太严格，以致于不适合特定的编程问题。在这种情况下，C++提供了另外一种形式的访问权限：友元。友元有3种：友元函数（可以访问类的私有成员的非成员函数）、友元类以及友元成员函数。
  通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。
  创建友元：将原型放在类声明中，前面加上关键字friend（函数不是成员函数，但与成员函数的访问权限相同）。定义时不要使用friend。
  常用的友元：重载<<运算符。
  只有接受一个参数的构造函数才能作为转换函数，但是如果一个构造函数含有两个参数，并且第二个参数提供了默认值，就可以进行自动转换。
  构造函数只用于从某种类型到类类型的转换。想要进行相反的转换，必须使用转换函数。
  用户定义的强制类型转换要注意：转换函数必须是类方法；转换函数不能指定返回类型；转换函数不能有参数。
第十二章 类和动态内存分配
  在 C++ 中，可以使用动态内存分配来为类对象动态分配内存。动态内存分配指的是在程序运行的过程中，根据需要动态地分配内存空间。与之相对应的是静态内存分配，即在程序编译时就就已经确定了内存的分配情况，无法根据程序运行的需要进行调整。
  动态内存分配的过程需要使用到两个运算符：new 和 delete。其中，new 运算符用于向操作系统申请内存空间，返回指向该空间的指针；delete 运算符用于释放之前申请的动态内存空间，使该空间变为可用状态。
  静态成员是属于整个类而不是属于类的具体实例的变量或函数。可以通过在类的内部声明静态成员，并在类的外部定义并初始化该成员来定义静态成员（如果静态成员是const整型类型或者枚举类型，则可以在类声明中初始化）。与普通成员不同的是，静态成员可以在不创建类实例的情况下被访问。
  静态成员函数可以访问类的静态成员变量，但不能访问类的非静态成员变量（静态成员函数没有this指针）。它可以通过类名来调用，也可以通过类的实例来调用。
  默认构造函数是不带参数的构造函数，如果没有手动实现构造函数，编译器会默认生成一个默认构造函数。它主要用于在创建对象时进行对象的初始化。如果类中有其他的构造函数，则需要显示地定义并实现默认构造函数，否则编译器不会生成默认构造函数。
  复制构造函数用于创建一个新对象，并使用另一个同类型的已有对象进行初始化。它的形式为：类名(const 类名& other)，它必须是 const 引用。如果类中没有手动实现复制构造函数，则编译器会默认生成一个复制构造函数。
  在构造函数中使用 new 时，需要注意：成对使用new和delete；定义一个复制构造函数，深度复制，将一个对象初始化为另一个对象；定义一个赋值运算符，深度复制，将一个对象复制给另一个对象；重点关注包含成员指针的对象（释放对象内存，但不会释放指针指向的内存，要在类析构函数中使用delete来释放）。
  有关返回对象的说明：
  1、返回指向const对象的引用：如果函数返回（通过调用对象的方法或将对象作为参数）传递给它的对象，可以通过返回引用来提高其效率。不会调用拷贝构造函数，旨在提高效率。
  2、返回指向非const对象的引用：常见的返回非const对象情形是，重载赋值运算符以及重载与cout一起使用的<<运算符。主要考虑对流运算符的重载（<< 或者 >>）。
  3、返回对象：如果被返回的对象是被调用函数中的局部变量，则不应按引用方式返回它。因为在被调用函数执行完毕时，局部对象将调用其析构函数。因此，当控制权回到调用函数时，引用指向的对象将不再存在。在这种情况下，应返回对象而不会引用。不能返回局部的引用。
  4、返回const对象。防止在if判断中将==写成=,改变对象的值，保护数据。
  总之，如果方法或函数要返回局部对象，则应返回对象，而不是指向对象的引用。在这种情况下，将使用复制构造函数来生成返回的对象。如果方法或函数要返回一个没有公有复制构造函数的类的对象，它必须返回一个指向这种对象的引用。最后，有些方法和函数（如重载的赋值运算符）可以返回对象，也可以返回指向对象的引用，在这种情况下，应首选引用，因为其效率更高。
  队列是一种常见的数据结构，它具有先进先出的特性，常用于打印任务等场景。在 C++中，可以使用标准库 queue 来实现队列的模拟。