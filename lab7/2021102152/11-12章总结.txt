第11章 使用类
11.1.运算符重载
运算符重载是C++的一种多态，C++允许将运算符重载拓展到用户定义的类型，如：将两个数组相加。数组相加通常需要for循环实现，但是在C++中可以定义一个表示数组的类，并重载运算符+。
11.2.计算时间：一个运算符重载示例
重载后的运算符必须至少有一个操作数是用户定义的类型，防止用户为标准类型重载运算符。
使用运算符时不能违反运算符原来的句法规则。不能修改运算符的优先级。不能创建新的运算符。
11.3.友元
友元是访问类对象私有部分的另一种形式。友元函数、友元类、友元成员函数。常规非成员函数不能直接访问类的私有数据，必须使用友元函数。
创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字friend；第二步编写函数定义。不要在定义中使用关键字 friend。
11.4.重载运算符：作为成员函数还是非成员函数
重载运算符时，不能同时使用重载的两种格式。
11.5.再谈重载：一个矢量类
-运算符有两个，一个是减号，有两个操作数；另一个是负号，一个操作数。
11.6.类的自动转换和强制类型转换
只有接受一个参数的构造函数才能作为转换函数，除非第二个参数提供默认值。
关键字 explicit 用于关闭自动转换时，传参时的隐式转换，但仍然运行显示转换。
转换函数必须是类方法，不能指定返回类型，不能有参数。
第12章 类和动态内存分配
12.1.动态内存和类
对于静态数据成员，特别注意的是静态类成员是单独存储的，并不是对象的组成部分，因此，不论创建了多少个对象，程序都只创建一个静态类变量副本，所有的对象共享同一个静态成员。
特殊成员函数：
默认构造函数 Klunk::Klunk(){ }带参数的构造函数也可以是默认构造函数，只要所有参数都有默认值，例如Klunk() {num = 0;}或者 Klunk(int n = 0) {num = n;}，这两者只能选其一，不然会有二义性。
默认析构函数；
复制构造函数 StringBad(const StringBad&);用于将一个对象复制到新创建的对象中，换言之，它用于初始化过程（包括程序生成对象副本时）而非常规的赋值过程。默认复制构造函数的功能是逐个复制非静态成员的值，若成员本身是对象，则使用这个类的复制构造函数来复制成员对象。静态成员不受影响，因为它们属于类而非对象。
赋值运算符；
地址运算符。
自动存储对象被删除的顺序与创建顺序相反。
默认的复制构造函数是浅复制。
12.2.改进后的新 String 类
字面值0有两种含义：可表示数字0，也可表示空指针。（void *）0、NULL、nullptr均可用于表示空指针。
12.3.在构造函数中使用 new 时应注意的事项
如果在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete。new对应于delete，new[]对应于delete[]。
12.4.有关返回对象的说明
当函数返回对象时，有四种方式可供选择，分别是返回指向const对象的引用、返回指向非const对象的引用、返回对象和返回const对象。
返回指向const对象的引用：返回const引用旨在提高程序的效率，因为返回对象需要调用复制构造函数，而返回引用不需要。
返回指向非const对象的引用：两种常见的返回非const对象引用的情况前文已经提及，便是在重载=运算符、<<和>>运算符时。
返回对象：被重载的算术运算符需要返回对象，因为它们并不应当修改传入的参数，而应该将结果存储在一个新的临时对象中，于是函数便只好返回实际的对象而非引用。
12.5.使用指向对象的指针
使用常规表示法来声明指向对象的指针：String *glamour；
可以将指针初始化为指向已有的对象：String *first=&sayings[0]；
使用new来初始化指针：String *favorite=new String(saying[choice]);
使用->运算符通过指针访问类方法：if(saying[i].length() <shortest->length())
12.7.队列模拟
调用构造函数时，对象将在代码块执行前被创建。对于 const 变量，可以使用成员初始化列表来进行初始化。
只有构造函数可以使用初始化列表。
数据成员被初始化的顺序与它们出现在类声明中的顺序相同，与初始化器中的顺序无关。