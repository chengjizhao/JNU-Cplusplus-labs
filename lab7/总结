第十一章
本章介绍了运算符重载、友元和对类执行自动类型转换。运算重载允许将标准C++运算符用于类对象；友元这种C++机制使得非成员函数可以访问私有数据。
一般来说，访问私有类成员的唯一方法是使用类方法。C++使用友元函数来避开这种限制。要让函数成为友元，需要在类声明中声明该函数，并在声明前加
上关键字 fiiend。
C++扩展了对运算符的重载，允许自定义特殊的运算符函数，这种函数描述了特定的运算符与类之间的关系。运算符函数可以是类成员函数，也可以是友元
函数(有一些运算符函数只能是类成员函数)。要调用运算符函数可以直接调用该函数，也可以以通常的句法使用被重载的运算符。对于运算符 op，其运算
符函数的格式如下:operatorop(argument-list)
C++允许指定在类和基本类型之间进行转换的方式。首先，任何接受唯一一个参数的构造函数都可被用作转换函数，将类型与该参数相同的值转换为类。如
果将类型与该参数相同的值赋给对象，则 C++将自动调用该构造函数。
要将类对象转换为其他类型，必须定义转换函数，指出如何进行这种转换，转换函数必须是成员函数。注意，转换函数没有返回类型、没有参数，但必须返
回转换后的值(虽然没有声明返回类型)。

第十二章
本章介绍如何对类使用new和delete以及如何处理由于使用动态内存而引起的一些微妙的问题。通常，最好是在程序运行时(而不是编译时)确定诸如使用多
少内存等问题。对于在对象中保存姓名来说，通常的 C++方法是，在类构造函数中使用 new 运算符在程序运行时分配所需的内存。为此，通常的方法是使
用 string 类，它将为您处理内存管理细节。
在类构造函数中，可以使用 new 为数据分配内存，然后将内存地址赋给类成员。这样，类便可以处理长度不同的字符串，而不用在类设计时提前固定数组
的长度。在类构造函数中使用 new，也可能在对象过期时引发问题。如果对象包含成员指针，同时它指向的内存是由 new 分配的，则释放用于保存对象的
内存并不会自动释放对象成员指针指向的内存。因此在类构造函数中使用 ew 类来分配内存时，应在类析构函数中使用 dclete 来释放分配的内存。这样，
当对象过期时，将自动释放其指针成员指向的内存。
如果对象包含指向 new 分配的内存的指针成员，则将一个对象初始化为另一个对象，或将一个对象赋给另一个对象时，也会出现问题。在默认情况下，C++
逐个对成员进行初始化和赋值，这意味着被初始化或被赋值的对象的成员将与原始对象完全相同。如果原始对象的成员指向一个数据块，则副本成员将指向
同一个数据块。当程序最终删除这两个对象时，类的析构函数将试图删除同一个内存数据块两次，这将出错。解决方法是:定义一个特殊的复制构造函数来重
新定义初始化，并重载赋值运算符。在上述任何一种情况下，新的定义都将创建指向数据的副本，并使新对象指向这些副本。这样，旧对象和新对象都将引用
独立的、相同的数据，而不会重叠。由于同样的原因，必须定义赋值运算符。对于每一种情况，最终目的都是执行深度复制，也就是说，复制实际的数据，而
不仅仅是复制指向数据的指针。
