第11章：
重载运算符，可以通过在类中对成员函数用operator+“运算符”代替函数名，使原本只能用于变量的运算符也通用于对象；
总的来说重载运算符不能违背原来的运算符的功能，并且不能创造新的运算符；
友元函数，可以调用类的私有保护变量但不是类的成员函数；
友元类，可以在类中声明其他类作为自己的友元类，从而使这个声明的友元类可以共享自己的私有成员。友元类不能传递，不可逆；
〈〈运算符是作为输出工具被重载的；
类的自动转换和强制转换类型

第12章：
不能在类声明中初始化静态成员变量，这是因为声明描述了如何分配内存，但并不分配内存；
this指针不能指向静态成员变量，因为静态成员变量不属于对象内的；
向类中存入字符串时，由于不能确定所需分配空间大小，分配过大内存会导致内存溢出，
故而要动态分配内存，使用new（）和delete（）。在构造函数中使用new（）分配，在析构函数中释放；
默认复制构造函数会导致假设类中有指针变量，不同对象同名的指针变量共享分配的内存，会出现错误（浅拷贝）；
简单来说浅拷贝，复制内容时，将指针复制过去会导致改变被复制的对象没有开辟新的空间，与我们想要的相悖。
所以深拷贝应该在想要复制的对象开辟动态的内存空间，再用strcpy复制内容。由于已经改变了重载运算符=故而应该在函数中把其余赋值也写上；