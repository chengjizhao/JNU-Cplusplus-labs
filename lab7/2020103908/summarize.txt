第十一章
    运算符重载就是允许赋予C++运算符多种意义，同时允许运算符重载扩展到用户定义
的类型上。例如，允许使用+将两个对象相加。编译器将根据操作数的数目和类型决定使
用哪种加法定义。重载运算符可使代码看起来更自然。
    创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字 frie
nd:friend Time operator*(double m,const Time & t); // goes in class decl
aration该原型意味着下面两点:虽然operator*()函数是在类声明中声明的，但它不是成
员函数，因此不能使用成员运算符来调用虽然operator*()函数不是成员函数，但它与成
员函数的访问权限相同。第二步是编写函数定义。为它不是成员函数，所以不要使用 Ti
me::限定符。另外，不要在定义中使用关键字friend。个很有用的类特性是，可以对<<
运算符进行重载，使之能与 cout 一起来显示对象的内容。
    对于很多运算符来说，可以选择使用成员函数或非成员函数来实现运算符重载。一般来
说，非成员函数应是友元函数，这样它才能直接访问类的私有数据。
    显然，应为矢量重载运算符。首先，无法用一个数来表示矢量，因此应创建一个类来表
示矢量。其次矢量与普通数学运算(如加法、减法)有相似之处。这种相似表明，应重载运算符，
使之能用于矢量。
    转换函数是用户定义的强制类型转换，可以像使用强制类型转换那样使用它们。注意，转
换函数没有返回类型、没有参数，但必须返回转换后的值(虽然没有声明返回类型)。

第十二章
    静态数据成员在类声明中声明，在包含类方法的文件中初始化。初始化时使用作用域运算
符来指出静态成员所属的类。但如果静态成员是整型或枚举型 const，则可以在类声明中初始化。
构造函数必须分配足够的内存来存储字符串，然后将字符串复制到内存中。在构造函数中使用 
new 来分配内存时，必须在相应的析构函数中使用 delete 来释放内存。如果使用 new](包括
中括号)来分配内存，则应使用 delete[l(包括中括号)]来释放内存。
    C++自动提供以下成员函数：
默认构造函数，如果没有定义构造函数:默认析构函数，如果没有定义;复制构造函数，如果没
有定义;赋值运算符，如果没有定义;地址运算符，如果没有定义。要认清C++会默认构造函数，
复制构造函数以及何时调用复制构造函数、默认的复制构造函数的功能的概念.
    如果在构造函数中使用new 来初始化指针成员，则应在析构函数中使用delete。
new和delete 必须相互兼容。new 对应于delete，new[]对应于delete:使用常规表示法来声
明指向对象的指针:String*glamour;可以将指针初始化为指向已有的对象:String *first=&
ayings[0];可以使用 new 来初始化指针，这将创建一个新的对象:String * favorite = ne
w String(sayings[choice]);对类使用new将调用相应的类构造函数来初始化新创建的对象:
// invokes default constructorString*gleep=new String;
// invokes the String(const char *) constructorString *glop=new String("my my my");
    队列存储有序的项目序列;队列所能容纳的项目数有一定的限制;应当能够创建空队列;
应当能够检查队列是否为空;应当能够检查队列是否是满的;应当能够在队尾添加项目;应当能够从
队首删除项目;应当能够确定队列中项目数。设计类时，需要开发公有接口和私有实现。
C++为类构造函数提供了一种可用来初始化数据成员的特殊语法。这种语法包括冒号和由逗号分隔
的初始化列表，被放在构造函数参数的右括号后，函数体的左括号之前。每一个初始化器都由被初
始化的成员的名称和包含初始值的括号组成。从概念上来说，这些初始化操作是在对象创建时进行
的，此时函数体中的语句还没有执行。