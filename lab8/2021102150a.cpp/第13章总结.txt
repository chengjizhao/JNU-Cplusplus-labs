第13章 类继承

s-a关系的继承。
如何以公有方式从一个类派生出另一个类。
保护访问。
构造函数成员初始化列表。
向上和向下强制转换。
虚成员函数。
早期（静态）联编与晚期（动态）联编。
抽象基类。
纯虚函数。
何时及如何使用公有继承

面向对象编程的主要目的之一是提供可重用的代码。通常，类库是以源代码的方式提供的，这意味着可以对其进行修改，以满足需求。然而，C++提供了比修改代码更好的方法来扩展和修改类。这种方法叫作类继承，它能够从已有的类派生出新的类，而派生类继承了原有类（称为基类）的特征，包括方法。

13.1 一个简单的类、
从一个类派生出另一个类时，原始类称为基类，继承类称为派生类。

派生类
派生类对象存储了基类的数据成员（派生类继承了基类的实现）；
派生类对象可以使用基类的方法（派生类继承了基类的接口）。

需要在继承特性中添加什么呢？
派生类需要自己的构造函数。
派生类可以根据需要添加额外的数据成员和成员函数。

构造函数访问权限
派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。
除非要使用默认构造函数，否则应显式调用正确的基类构造函数。

有关派生类构造函数的要点如下：
首先创建基类对象；
派生类构造函数应通过成员初始化列表将基类信息传递给基类构造函数；
派生类构造函数应初始化派生类新增的数据成员。

要使用派生类，程序必须要能够访问基类声明。

派生类与基类之间有一些特殊关系。其中之一是派生类对象可以使用基类的方法，条件是方法不是私有的：
基类指针可以在不进行显式类型转换的情况下指向派生类对象；
基类引用可以在不进行显式类型转换的情况下引用派生类对象：

13.2 继承is-a关系
C++有3种继承方式：公有继承、保护继承和私有继承。公有继承是最常用的方式，它建立一种is-a关系，即派生类对象也是一个基类对象，可以对基类对象执行的任何操作，也可以对派生类对象执行。

公有继承不建立has-a关系，也不建立is-like-a关系，以及is-implemented-as-a（作为……来实现）关系，uses-a关系。

13.3多态公有继承
可能会遇到这样的情况，即希望同一个方法在派生类和基类中的行为是不同的。换句话来说，方法的行为应取决于调用该方法的对象。这种较复杂的行为称为多态——具有多种形态，即同一个方法的行为随上下文而异。

有两种重要的机制可用于实现多态公有继承；
在派生类中重新定义基类的方法。
使用虚方法。

13.4静态联编和动态联编

将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编（binding）。在编译过程中进行联编被称为静态联编（static binding），又称为早期联编（early binding）。使用虚函数时，由于编译器不知道用户将选择那种类型的对象，因此编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编（dynamic binding），又称为晚期联编（late binding）。

指针和引用类型的兼容性
在C++中，动态联编与通过指针和引用调用方法相关，从某种程度上说，这是由继承控制的。
指向基类的引用或指针可以引用派生类对象，而不必进行显式类型转换。
将派生类引用或指针转换为基类引用或指针被称为向上强制转换（upcasting），这使公有继承不需要进行显式类型转换。

向上强制转换是可传递的

相反的过程——将基类指针或引用转换为派生类指针或引用——称为向下强制转换（downcasting）。

动态联编能够让用户重新定义方法，而静态联编的效率更高。在不需要使用虚函数的情况下，默认使用静态联编

虚函数的工作原理
    通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表（virtual function table，vtbl）。虚函数表中存储了为类对象进行声明的虚函数的地址。。例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址；如果派生类没有重新定义虚函数，该vtbl将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数的地址也将被添加到vtbl中。
    调用虚函数时，程序将查看储存在对象中的vtbl地址，然后转向相应的函数地址表。如果使用类声明中定义的第一个虚函数，则程序将使用数组中的第一个函数地址，并执行具有该地址的函数。如果使用类声明中的第三个虚函数，程序将使用地址为数组中第三个元素的函数。

虚函数的注意事项
在基类方法的声明中使用关键字virtual可使该方法在基类以及所有
的派生类（包括从派生类派生出来的类）中是虚的。
如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象
类型定义的方法，而不使用为引用或指针类型定义的方法。这称为
动态联编或晚期联编。这种行为非常重要，因为这样基类指针或引
用可以指向派生类对象。
如果定义的类将被用作基类，则应将那些要在派生类中重新定义的
类方法声明为虚的

13.5 访问控制 protected

关键字protected与private相似，在类外只能用公有类成员来访问protected部分中的类成员。派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。

13.6 抽象基类（abstract base class，ABC）
ABC描述的是至少使用一个纯虚函数的接口，从ABC派生出
的类将根据派生类的具体特征，使用常规虚函数来实现这种接口。

13.7 继承和动态内存分配

第一种情况，派生类不适用new
不需要为派生类定义显示析构函数、复制构造函数和赋值运算符。
派生类对象的这些属性也适用于本身是对象的类成员。

第二种情况：派生类使用new
必须为派生类定义显式析构函数、复制构造函数和赋值运算符。

