第13章类继承
一个简单的基类通常包括一些数据成员和成员函数，而这些成员函数可以用于被派生类继承或重写。
派生类名：指定要派生的类的名称。
基类名：指定要继承的基类名称。
访问修饰符：可选项，表示派生类对于基类的访问权限，默认为 private。
使用派生类通常与使用其基类类似。派生类通常可以继承基类的公有成员函数和公有数据成员，并且可以添加自己的成员函数和成员变量。此外，我们还可以使用基类的指针或引用来访问派生类的对象，称为“向上转型”。
需要注意的是在使用指向派生类对象的基类指针或引用时，虽然我们可以访问基类的成员函数，但是无法访问派生类特有的成员函数和成员变量，因为这些成员是派生类特有的，基类指针或引用无法访问到。如果需要访问派生类特有的成员，可以使用强制类型转换来将指针或引用转换为派生类指针或引用。
13.1.3使用派生类
使用派生类通常与使用其基类类似。派生类通常可以继承基类的公有成员函数和公有数据成员，并且可以添加自己的成员函数和成员变量。此外，我们还可以使用基类的指针或引用来访问派生类的对象，称为“向上转型”。
13.1.4 派生类和基类之间的特殊关系
派生类可以访问基类的公有成员，但不能访问基类的私有成员。
派生类可以重写基类的虚函数，以提供特定于派生类的实现。当使用基类指针或引用来访问派生类对象时，将根据对象的实际类型调用相应的成员函数。
派生类可以添加自己的成员函数和成员变量，从而扩展其基类的功能。
如果一个派生类直接或间接地继承了多个同名的虚函数，那么必须在派生类中显式地指明要使用的虚函数。这通常可以通过使用作用域解析符（::）来实现，或者使用 using 声明来引入基类中的某个成员函数。
基类的构造函数会在派生类的构造函数中自动调用，以初始化基类的数据成员。在派生类的构造函数中，可以使用成员初始化列表来初始化基类的构造函数，或者通过调用基类的构造函数来完成初始化。
基类的析构函数也会在派生类的析构函数中自动调用，以释放基类的资源。在派生类的析构函数中，不需要显式地调用基类的析构函数，因为这会自动发生。
13.2继承：is-a关系
继承建立了类与类之间的“is-a”关系。在继承中，派生类会从基类继承一些属性和方法，从而可以拓展已有的代码。继承在C++中以public 、protected、private访问修饰符为基础实现，表示派生类对基类的访问权限。public 表示公共继承，protected表示保护继承，private表示私有继承。
13.3 多态公有继承
多态是面向对象编程的一种信息隐藏和代码灵活性的机制，它允许我们使用统一的方式处理不同类型的对象。在C++中，多态是通过虚函数实现的，它可以在运行时确定实际调用的成员函数。
在使用多态时，通常需要使用公有继承和虚函数来实现。公有继承表示派生类对基类的访问权限，而虚函数表示在派生类中重写基类的函数，从而实现多态的效果。
13.4、静态联编和动态联编
静态联编也称为早绑定，是在编译期间完成函数调用的解析。在静态联编中，编译器根据函数的名称、参数数量和类型来确定调用哪个函数。由于解析过程在编译期间完成，因此在运行时不需要额外的开销，具有较高的效率。
动态联编也称为晚绑定，是在运行时根据实际对象类型进行函数的解析。在动态联编中，调用一个虚函数时，编译器会为对象生成一个虚表，虚表中存储了实际对象类型的信息及其对应的虚函数地址，从而实现在运行时根据实际对象类型调用正确的函数，而不是根据指针类型调用函数。由于解析过程在运行时完成，因此具有较高的灵活性。
13.4.1指针和引用类型的兼容性
c++不约下将一种类型的地址赋给另一种类型的指针，引用同样如此。
13.4.2虚成员函数和动态联编
将一个成员函数声明为virtual，就可以将其定义为“虚函数”，从而使得该函数可以进行动态联编（dynamic dispatch）
13.5、访问控制：protected
用protected来控制对类成员的访问。
13.6抽象基类
抽象基类是指它包含至少一个纯虚函数（pure virtual function）的类，纯虚函数是在基类中声明但没有实现的虚函数。抽象基类不能被直接实例化，只能通过其派生类来创建对象。由于至少有一个纯虚函数没有实现，因此抽象基类的派生类必须实现所有的纯虚函数才能被实例化。
13.7、继承和动态内存分配
当使用new操作符来创建派生类对象时，需要先为基类子对象分配内存空间，再为派生类对象分配内存空间。此时，需要调用基类构造函数来初始化基类子对象。
13.7.1使用与不使用new来创建派生对象，要注意，先调用的基类的构建函数，再调用派生类的构建函数，析构函数则相反。