13.1 一个简单的基类
从一个类派生出另一个类时，原始类称为基类，继承类称为派生类。
13.1.1 派生一个类
冒号指出RatedPlayer类（派生类）的基类是TableTennisplayer类。public表明TableTennisPlayer是一个公有基类，这被称为公有派生。派生类对象包含基类对象。使用公有派生，基类的公有成员将成为派生类的公有成员；基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问。
派生类对象存储了基类的数据成员（派生类继承了基类的实现）；派生类对象可以使用基类的方法（派生类继承了基类的接口）。派生类需要自己的构造函数。构造函数必须给新成员和继承的成员提供数据。派生类可以根据需要添加额外的数据成员和成员函数。
13.1.2 构造函数：访问权限的考虑
派生类不能直接访问基类的私有成员，而必须通过基类方法进行访问。创建派生类对象时，程序首先调用基类构造函数，然后再调用派生类构造函数。基类构造函数负责初始化继承的数据成员；派生类构造函数主要用于初始化新增的数据成员。
派生类的构造函数总是调用一个基类构造函数。可以使用初始化器列表语法指明要使用的基类构造函数，否则将使用默认的基类构造函数。派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数。
派生类的默认构造函数总是要进行一些操作：执行自身的代码后调用基类析构函数。
13.1.4 派生类和基类之间的特殊关系
基类指针（或引用）可以在不进行显式类型转换的情况下指向（或引用）派生类对象；派生类对象可以使用基类的方法，派生类方法可以调用基类的方法（必要时加作用域解析符::）基类指针或引用只能用于调用基类方法。
C++要求引用和指针类型与赋给的类型匹配，但这一规则对继承来说是例外。不可以将基类对象和地址赋给派生类引用和指针。对于形参为指向基类的指针的函数，可以使用基类对象的地址或派生类对象的地址作为实参。
可以将基类对象初始化为派生类对象，也可以将派生对象赋给基类对象
13.2 继承：is-a关系
C++有3种继承方式：公有继承、保护继承和私有继承。
公有继承是最常用的方式，它建立一种is-a关系，即派生类对象也是一个基类对象，可以对基类对象执行的任何操作，也可以对派生类对象执行。公有继承不建立 has-a关系。公有继承不能建立is-like-a关系。公有继承不建立is-implemented-as-a（作为……来实现）关系。公有继承不建立uses-a关系。
13.3 多态公有继承
同一个方法在派生类和基类中的行为是不同的。在派生类中重新定义基类的方法，需要使用虚方法。然后，程序将根据对象类型而不是引用（或指针）的类型来选择方法版本。方法在基类中被声明为虚的后，它在派生类中将自动成为虚方法。
关键字virtual只用于类声明的方法原型中，而没有用于方法定义中。如果析构函数不是虚的，则将只调用对应于指针类型的析构函数。如果析构函数是虚的，将调用相应对象类型的析构函数。如果派生类包含一个执行某些操作的析构函数，则基类必须有一个虚析构函数，即使该析构函数不执行任何操作。
可以创建指向 Brass的指针数组。这样，每个元素的类型都相同，但由于使用的是公有继承模型，因此Brass指针既可以指向Brass对象，也可以指向 BrassPlus对象。因此，可以使用一个数组来表示多种类型的对象。这就是多态性。
如果要在派生类中重新定义基类的方法，则将它设置为虚方法；否则，设置为非虚方法。
13.4 静态联编和动态联编
将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编（binding）
在编译过程中进行联编被称为静态联编（static binding）
虚函数使编译器必须生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编（dynamic binding）
13.4.1 指针和引用类型的兼容性
将派生类引用或指针转换为基类引用或指针——称为向上强制转换（upcasting），这使公有继承不需要进行显式类型转换。
将基类指针或引用转换为派生类指针或引用——称为向下强制转换（downcasting）。如果不使用显式类型转换，则向下强制转换是不允许的。
隐式向上强制转换使基类指针或引用可以指向基类对象或派生类对象，因此需要动态联编。C++使用虚成员函数来满足这种需求。
13.4.2 虚成员函数和动态联编
编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表（virtual function table，vtbl）。虚函数表中存储了为类对象进行声明的虚函数的地址。
使用虚函数时，在内存和执行速度方面有一定的成本：每个对象都将增大，增大量为存储地址的空间；对于每个类，编译器都创建一个虚函数地址表（数组）；对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。
13.4.3 有关虚函数注意事项
在基类方法的声明中使用关键字virtual可使该方法在基类以及所有的派生类（包括从派生类派生出来的类）中是虚的。
如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为动态联编或晚期联编。这种行为非常重要，因为这样基类指针或引用可以指向派生类对象。
如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚的。
构造函数不能是虚函数。创建派生类对象时，将调用派生类的构造函数，而不是基类的构造函数，然后，派生类的构造函数将使用基类的一个构造函数，这种顺序不同于继承机制。因此，派生类不继承基类的构造函数，所以将类构造函数声明为虚的没什么意义。
析构函数应当是虚函数，除非类不用做基类。即使基类不需要显式析构函数提供服务，也不应依赖于默认构造函数，而应提供虚析构函数，即使它不执行任何操作：virtual ~Brass() {}
友元不能是虚函数，因为友元不是类成员，而只有成员才能是虚函数。如果由于这个原因引起了设计问题，可以通过让友元函数使用虚成员函数来解决。
如果派生类没有重新定义函数，将使用该函数的基类版本。如果派生类位于派生链中，则将使用最新的虚函数版本，例外的情况是基类版本是隐藏的。
重新定义继承的方法并不是重载。如果在派生类中重新定义函数，将不是使用相同的函数特征标覆盖基类声明，而是隐藏同名的基类方法，不管参数特征标如何。
如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。这种特性被称为返回类型协变（covariance of return type），因为允许返回类型随类类型的变化而变化。
如果基类虚函数声明被重载了，则应在派生类中重新定义所有的基类版本。如果只重新定义一个版本，则另外两个版本将被隐藏，派生类对象将无法使用它们。
13.5 访问控制：protected
关键字protected与private相似：在类外只能用公有类成员来访问protected部分中的类成员。private和protected之间的区别：派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。
13.6 抽象基类（abstract base class，ABC）
有些基类的方法和数据在派生类中用不到，浪费资源。
例如：从Ellipse和Circle类中抽象出它们的共性，将这些特性放到一个ABC中。然后从该ABC派生出Circle和Ellipse类（具体类）。这样，便可以使用基类指针数组同时管理Circle和Ellipse对象，即可以使用多态方法。
要成为真正的ABC，必须至少包含一个纯虚函数。当类声明中包含纯虚函数时，则不能创建该类的对象（不能实例化）。包含纯虚函数的类只用作基类。C++通过使用纯虚函数（pure virtual function）提供未实现的函数。纯虚函数声明的结尾处为=0。virtual double Area() = 0;在ABC中可以不定义该函数。
13.7 继承和动态内存分配
第一种情况：假设基类使用了动态内存分配，派生类不需执行任何特殊操作，不需要为派生类定义显式析构函数、复制构造函数和赋值运算符。
复制类成员或继承的类组件时，则是使用该类的复制构造函数完成的。（lacksDMA类的默认复制构造函数使用显式baseDMA复制构造函数来复制lacksDMA对象的baseDMA部分。）
类的默认赋值运算符将自动使用基类的赋值运算符来对基类组件进行赋值。
派生类对象的这些属性也适用于本身是对象的类成员。
第二种情况：假设基类和派生类都使用了new，在这种情况下，必须为派生类定义显式析构函数、复制构造函数和赋值运算符。
派生类析构函数自动调用基类的析构函数，而自身析构函数是对派生类新增指针成员指向内存的释放。
派生类复制构造函数在初始化成员列表中调用基类的复制构造函数，如果不这样做，将自动调用基类的默认构造函数。基类复制构造函数有一个基类引用参数，而基类引用可以指向派生类型。（baseDMA复制构造函数将使用hasDMA参数的baseDMA部分来构造新对象的baseDMA部分）。
派生类的显式赋值运算符可以通过作用域解析运算符显式调用基类赋值运算符，完成所有继承的基类对象的赋值。
13.9 总结
继承通过使用已有的类（基类）定义新的类（派生类），使得能够根据需要修改编程代码。公有继承建立is-a关系，这意味着派生类对象也应该是某种基类对象。作为is-a模型的一部分，派生类继承基类的数据成员和大部分方法，但不继承基类的构造函数、析构函数和赋值运算符。派生类可以直接访问基类的公有成员和保护成员，并能够通过基类的公有方法和保护方法访问基类的私有成员。可以在派生类中新增数据成员和方法，还可以将派生类用作基类，来做进一步的开发。每个派生类都必须有自己的构造函数。程序创建派生类对象时，将首先调用基类的构造函数，然后调用派生类的构造函数；程序删除对象时，将首先调用派生类的析构函数，然后调用基类的析构函数。
如果要将类用作基类，则可以将成员声明为保护的，而不是私有的，这样，派生类将可以直接访问这些成员。然而，使用私有成员通常可以减少出现编程问题的可能性。如果希望派生类可以重新定义基类的方法，则可以使用关键字virtual将它声明为虚的。这样对于通过指针或引用访问的对象，能够根据对象类型来处理，而不是根据引用或指针的类型来处理。具体地说，基类的析构函数通常应当是虚的。
可以考虑定义一个ABC：只定义接口，而不涉及实现。例如，可以定义抽象类Shape，然后使用它派生出具体的形状类，如Circle和Square。ABC必须至少包含一个纯虚方法，可以在声明中的分号前面加上=0来声明纯虚方法。
不一定非得定义纯虚方法。对于包含纯虚成员的类，不能使用它来创建对象。纯虚方法用于定义派生类的通用接口。
